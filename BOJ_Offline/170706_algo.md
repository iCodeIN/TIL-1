## 2회차
* DP

- 연속합
    - 모든 부분 수열을 구해서 할 수는 있지만 너무 시간이 오래 걸림.
    - i번째 구할 때, i-1번째 배열은 연속한 숫자의 합 중 가장 큰 값만 가지고 있으면 된다.
    이걸 점화식으로 쓰면 됨
        - `D[i] = i번째에서 끝나는 가장 큰 연속합`
        - `D[i] = max(D[i-1] + A[i], A[i]);
    - 시간 복잡도는 O(n)

- 연속합 2
    - 수를 하나 지울 수 있는 차이점이 있음.
    - 왼쪽에서 구한 연속합이랑 오른쪽에서 구한 연속합에서 구하면 됨
    - O(n)

- 제곱수의 합
    - `D[i] = min(D[i-j^2] + 1)` (1 <= j^2 <= i)
    - 시간 복잡도는 N * root N

- 풀면서 주의할 점
    - 되도록 실수 처리 없이 정수로 해결할 수 있도록 (float, double 쓸일 있긴 하지만 대부분은 정수 씀)

- 합분해
    - 1,2,3 더하기나 제곱수의 합이랑 비슷한 문제.
    - 0부터 N까지의 정수 K개 더해서 그 합이 N이 되는 경우의 수 구하기
    - K*N^2
    - 불필요한 계산을 줄여서 복잡도를 줄일 수 있음!
        - `D[K][N] = sigma D[K-1][L] (0 <= L <= N)`
    
- 암호 코드
    - i번째 문자까지 해석했을 때, 가능한 경우
    - i-1번째까지 계산하고 더하면서 올라가기

- 다이내믹 프로그래밍에서 초기화를 어떻게 할 것인가?

* 수학
- 소수 구하기
    - 면접에서는 n*n 방법, 문제 풀때는 에라토스테네스의 체를 많이 쓰는듯

- 팩토리얼
    - 시간 복잡도 면에서는 10팩토리얼이 기준.
    (3628800)


* 그래프
- 방향 있는 그래프 / 없는 그래프
    - 방향이 없으면 보통 양방향이라고 함 (간선 두개로 나누어서 저장함)

- 루프나 간선 여러개는 가끔 있음.

- 가중치 : 거리 시간 비용..
- 차수 : 정점과 연결되어 있는 간선 개수 (in-degree, out-degree)

- 그래프는 어떻게 저장함?
    - 인접행렬
    - 인접리스트
    - 간선리스트

    - 정점이 아니라 간선을 저장하겠다는 거임

    - 인접행렬은 잘 안씀 (귀찮을때, N 제한이 작은데 뭔가 빨리 구현하고 싶을 때)
        - 비효율적이래요
        - 2차원 배열 만들어서 `A[i][j] = 1, 0` (간선 있으면 1, 없으면 0)
        - 정점이 N개면 공간은 N^2개 필요.

    - 인접리스트는 링크드 리스트를 통해서 구현함
        - 근데 링크드 리스트는 어려우니 C++은 벡터, 자바는 어레이리스트 이용해서 구현
        (강의 슬라이드에 소스 코드 있음)
        ```java
        ArrayList<T>[] a = (ArrayList<T>[] ) new ArrayList[]
        ```
        - 정점 V개, 간선 E개인 경우 공간은 E개 필요
            - 저장되는건 간선의 개수니까
        - A[i]에는 i랑 간선으로 연결된 애들 목록을 저장

    - 왜 인접리스트를 씀?
        - 보통 문제에서 V는 10만, E는 100만 정도의 제한이 있는데 공간면에서 훨씬 효율적임
        (인접 행렬은 V^2, 인접 리스트는 E)
    
    - 간선리스트는 배열에 간선을 저장함

- 그래프의 탐색!
    - DFS, BFS
    - 최단거리 알고리즘
    - 네트워크 플로우

    - 탐색의 목적은?
        - 모든 정점을 한번씩 방문하는 것

    - DFS 깊이 우선 탐색 (스택)
        - 한명이 최대한 깊게 들어가는거
        - 어디를 거쳐서 왔는지 스택에 다 넣어놓고, 더이상 갈곳이 없으면 걔를 스택에서 뺌.
        - 재귀 호출을 이용해서 구현할 수 있음. 그리고 인접 리스트 이용
        - 시간 복잡도는?
            - O(V^2) -> 인접 행렬 이용했을 때
            - 함수 호출이 V번 됨. 인접 리스트 이용하면? V+E
            - 보통 E가 V보다 많으니까 O(E)라고 쓸 때가 많음
    - BFS 너비 우선 탐색 (큐)
        - 여러명으로 복제해서 찾는거
        - 현재 지점에서 갈 수 있는 곳을 다 가보는데, 큐를 이용함
        - 큐에 넣었다는건 해당 정점을 방문했다는 의미임
        - 시간 복잡도는?
            - 모든 정점이 큐에 한번씩 들어갔다 나오는데, 끝나고보니 모든 간선을 한번씩 검사하니까 V+E
            
- 연결 요소
    - DFS, BFS 둘다 가능

- 이분 그래프
    - 그래프를 두개로 나눌 수 있음 (슬라이드 참고)
    - 이분 매칭에서 중요함
    - 탐색으로 빨-파 관계인지 파악하기

- 플러드 필
    - 배열 채우기
    - 단지번호붙이기 (2667) -> BFS, DFS로 풀기 가능한 그래프 문제
        - 지도에 써있는 숫자들끼리 간선으로 연결해본다고 생각하면 이해하기 쉬운듯..
    - 섬의 개수 (4963)
        - 단지번호가 4방향이라면 얘는 8방향임.
        - Dx, Dy 배열 만들어놓고 처리하는게 편할듯.

- 탐색법 어디에 쓰나?
    - DFS는 잘 안쓰임, 간단하게 뭐 해야할 때 쓰임. 아니면 고급 알고리즘에서 ㅇㅇ
        - 강한 연결 요소 구한다거나 (DFS 트리?)
        - 다른 알고리즘에서 선처리할때 쓴다거나..
    - BFS는 특징이 있다?
        - 단계별로 진행이 됨. 갈 수 있는거 다 가보고 그담에 또 갈 수 있는거 다 가보고..
        - 거리 순으로 방문을 함.
        - 모든 경우의 수를 해봐야할 때 쓸수도 있음. (완전탐색에서 배울 예정)

    - 미로탐색(2178)은 BFS로만 구할 수 있다?
        - DFS의 목적은 모든 정점을 한번 방문하는거지, 최소로 방문하는게 아님.
        - BFS로 해야 최단거리 구할 수 있다!


- 과제
    - 완전 탐색 슬라이드에 있는 문제들 읽고 오기