## 5회차

### 분할 정복
* DP와 다르게, 중복이 발생하지 않음 (문제 안겹침)
* 시간 복잡도에 log가 붙는 경우가 많음
    * 절반으로 나누는 경우가 많아서..

#### 이분 탐색
* 일단 정렬되어 있어야함
* O(Log N)
    * 복잡도에 log가 들어가는 경우, 대부분 밑이 2인 로그임.

* 이 알고리즘의 원리를 이용해서 푸는 문제들이 있음.

#### Merge Sort
* N개를 N/2, N/2로 나눔, 계속 나누다가 더이상 나눌 수 없을 때 정렬하고 정렬한 결과를 합침.
* O(N log N)
    * 나누는데 log N, 합칠 때 N -> N * log N

#### Quick Sort
* 평균적인 상황에서 제일 빠름
* 최악일 때 O(N^2)
    * 피벗을 두개 놓는 방법도 존재

* stable sort?
    * 정렬하기 전의 순서가 유지되는 정렬 알고리즘을 말함
    * 퀵 소트는 stable이 아님
    * 머지 소트는 stable임

#### 문제풀기
* lower bound : 크거나 같으면서 가장 작은수
* upper bound : 크면서 가장 작은수
```
1 2 3 3 3 4 4 5 7 7 8 9 9....
3의 lower bound : 첫번째 3
3의 upper bound : 4
6의 lower bound : 7
6의 upper bound : 7
(이유 : 6이 없으니까...)
```

* 하노이 탑 이동 순서 (11729)
    * O(2^N)

* 분할정복이나 DP를 잘 못풀겠다면?
    * 손으로 한 6까지 전개해보면 눈에 보이는경우가 있음.. 수를 써보고 규칙을 찾는 방법도 나쁜 방법은 아님!

* 분할정복을 푸는 방법?
    * 무조건 재귀로.

* 트리 순회 (2263)
    * 트리가 어떻게 생겼는지 전혀 모르는데, in-order랑 post-order를 보고 pre-order 만들 수 있는지 해보는 문제

```
pre : 정점 l r
in : l 정점 r
post : l r 정점
```

* Z (1074)
    * 이미지 생긴걸 보면 4등분을 해야될거 같이 생긴 문제 (?)

* 버블소트 (1517)
    * 교환을 몇번 했는지 시간 제한 내에 어떻게 알 수 있을까?
    * 버블소트의 성질을 이용해서 분할 정복을 하자!
        * 최소 단위(2개)까지 쪼개고, merge 해보면서.. 거기서 스왑이 몇번 일어났는지 계산

### 그리디

* 뒤의 상황은 나중에 생각하고, 일단 지금 제일 좋은걸 선택하기
    * 어떤 상황에서도 제일 좋아보이는거!
    * 그리디는 처음 세운 기준을 끝까지 유지해야된다.

* 거스름돈 문제
    * 지폐와 동전의 개수가 배수의 법칙을 만족했을 때에만 그리디가 성립
    * 동전이 어떻게 될지 모를땐 그리디가 통하지 않음 (1,4,5원 있을때 12원을 거슬러준다던지에서 반례 발생함)

* 회의실 배정 (1931)
    * 일찍 시작하는 회의, 짧은 회의를 기준으로 잡으면 반례가 있다.
    * 그렇다면 최대한 최적해가 발생할 가능성이 높은 것은..?
        * 빨리 끝나는거!

* ATM (11399)
    * 기다리는 시간이 짧은 사람을 기준으로

* 병든 나이트 (1783)
    * height = 1, 2, 3 이상인 경우를 각각 나눠서 생각
        * height가 3 이상인 경우 width가 7보다 큰지, 작거나 같은지
        * 이동 횟수 4번 이상인 경우 모든 방법을 써야된다는 것을 고려하면서 최대한 1번과 4번 이동 방법을 많이 할 수 있는 경우의 수!

* NMK (1201)

* 행렬 (1080)
    * 1이랑 0밖에 없는 배열을 가지고 3*3 부분 배열을 뒤집어서 몇번만에 B배열로 바꿀 수 있는지 구하기 (못구하는 경우 -1 출력)
    * 모든 방법 다해보기에는 시간이 오래 걸린다.
    * 그래서 어떤 특징을 발견하게 된다.
        * 같은 상태를 다시 반복하는건 불필요하다. (방금 A의 어떤 부분을 뒤집었는데, 그 부분을 바로 다시 뒤집을 필요가 없음)
        * 상태를 바꿀 수 있는 방법이 한가지밖에 없는 칸의 숫자가 B 배열이랑 다른 경우, 무조건 그 방법을 사용해야한다.
            * 처음에는 두가지 방법인 칸도 있겠으나, 어느 한가지 방법을 사용한 뒤에는 한가지 방법으로 좁혀지는 칸이 있음!

            예시 : 0,0을 기준으로 뒤집은 뒤에, 0,1의 상태 값을 변경할 수 있는 방법은?

* 전구와 스위치 (2138)
    * 스위치를 어떻게 누를지 결정하면, 그 다음에는 걔를 건드리지 않는다는 규칙으로 접근
    * 제일 처음 스위치 건드렸냐 아니냐로 분할해서 두번 풀기.
        * 복잡도는? O(2N) -> O(N)
    
* 동전 뒤집기 (1285)

* 롤러코스터 (2873)
    * 짝수 곱하기 짝수인 경우 모든 칸에 방문 불가 (어떻게 해도 한칸은 방문 못함)
    * 체스판처럼 흰색 검정색 칠해놓고 보면, 방문을 안하는 칸은 무조건 검정색 칸 (자세한 내용은 슬라이드 참고)
    * 구현에 신경을 좀 써줘야함.. (백트래킹?)
    