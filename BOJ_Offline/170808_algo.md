## 11회차
* 세그먼트 트리 활용 문제
    * 굉장한 학생 (2336)
        * 세번의 시험을 잘 본 사람을 찾는 문제
        * 세그먼트 트리로 문제를 풀려면 트리에 무엇을 넣어야할지에 대한 정의가 필요.
            * 이 문제에서는 `tree[i]`에 뭐가 들어가느냐?
            * `tree[i]` = 1번 시험을 i등한 사람의 3번 시험 등수
            * 우선 2번 시험을 잘본 사람 순으로 정선
            * 트리의 초기값은 전체 인원수(10명)보다 큰 11로 초기화
    * 라운드 로빈 스케줄러 (12016)
        * 먼저 완료되는 문제부터 살핌
    * 음주 코딩 (5676)
        * 구간의 곱을 구해야 하는 문제 -> 세그먼트 트리로
        * 펜윅 트리로는 못함. 왜?
            * 0 때문에..
        * 각 부호가 몇개 있는지가 중요하기 땜에 원래 숫자말고 그냥 -1, 0, 1 저장해서 풀면 되는 문제
    * 조세퍼스 문제 (1168)
        * 세그먼트 트리로 O(n log n) 해법이 있는데, 이거 말고도 O(N) 해법이 있음.
    * 세그먼트 트리는 언제 써야할지 감이 잘 안온다. (DP나 다른거에 비해)

* 상태 다이나믹
    * 엄청 큰 피보나치 -> 수 제한이 10^18이라면?
        * 피보나치에는 어떤 주기가 있다.
        * 행렬을 이용해서도 표현 가능.
        * 2진수의 원리 이용
            * 3^27이라는 수가 있을 때, 27은 이진수로 11011 = 1+2+8+16
    * O(N!) 문제는 거의 O(2^N)으로 바꿀 수 있고, 여기서 DP가 사용된다.
    * 외판원 순회 (2098)
        * N <= 16이라 O(N!) 방법 못함
        * 이전에 설명한대로 시작도시를 1로 고정할 수 있다.
        * 어디를 방문? -> 상태 2^N
        * `D[S][i]` = 방문한 도시 집합 S, 마지막 도시 i
            * `D[S^(1<<i)][j] + W[j][i]`
    * 계단 수 (1562)
        * 쉬운 계단수와 다르게, 0부터 9까지 다 등장했는지가 중요한 상태 다이나믹 문제
        * `D[N][L][S]` = 길이 N, 마지막 L, 상태 S
    * 다이나믹 문제 풀때 '등장' 같은 키워드가 있는 경우, 상태 다이나믹일 수 있다.
    * 컨닝 (1014)
        * 상태 다이나믹은 점화식보다 코드가 중요
    * 격자판 채우기 (1648)
        * 조금 독특한 형태의 다이나믹 문제임

* 네트워크 플로우
    * 그래프에서의 가중치는 cost와 capacity가 있다.
        * cost는 버스를 이용하면서 지불하는 비용, capacity는 최대 정원
    * 네트워크 플로우는 capacity가 있는 그래프에서 물을 흘린다고 쳤을 때, 최대 흐를 수 있는 양을 구하는 것
        * 물 대신 차로 생각해보면, 이 간선에서 차가 몇대 지나갈 수 있느냐
        * cost는 간선을 한번 지나가면 그 비용을 모두 지불해야되지만, capacity는 1 지나가면 1만큼 감소
        * 간선에 나타나있는 것 : capacity
        * 실제 그 간선을 따라서 흐른 양 : flow
    * 네트워크 플로우로 풀 수 있는 문제가 많음 (문제보다는 현업?)
    * 그래프 G가 있고, u -> v 방향의 간선이 있을 때
        * u -> v 간선의 용량 : c(u, v)
        * u -> v 간선의 흐른 양 : f(u, v)
        * f(u, v) <= c(u, v)
        * f(u, v) = -f(u, v)
    * cf(u, v) = c(u, v) - f(u, v)
    * Augmenting Path? s에서 t로 가는 경로
    * Ford-Fulkerson
        * 최대 유량 (maximum flow)을 구하는 알고리즘
        * DFS 사용
        * O(EF) -> F는 맥시멈 플로우 개수
    