## 7회차

* 동전1 (2293)
    * `D[i] = D[i - A[i]] + 1`
    * 중복 제거를 고려해서 풀기
    * 동전2도 비슷하게 풀 수 있음

* 고층 빌딩 (1328)
    * N개가 있다고 치고, 하나가 빠지거나 추가됐을때 어떤 일이 벌어지는지 기록
    * 몇차원 DP배열을 만들지도 고민
        * 2차원 배열로 풀어야 하는 문제가 1차원 배열로 풀리는 경우는 별로 없다. 다 2차원으로 하는 이유가 있어서 그렇게 해야되는 것..
        * 고층 빌딩 문제는 3차원 DP (N, L, R)

* 기타리스트 (1495)
    * 전체 개수가 너무 많아서 DP로 해야됨 (일일히 하는 경우 2^100)
    * 현재 곡을 어느 볼륨으로 연주해야하냐가 중요한 문제임 (과거는 중요한 정보가 아님)
    * 0과 1만 기록하기 때문에, DP 배열에 정답이 안써있음 (연주할 수 있나 없나만 구함)
        * 그래서 답을 구하는 과정이 한번 더 필요함
    * 음수 인덱스를 쓸 수 없으니 2 * M개 잡아서 기록하고, 출력 할때는 마이너스 해줘서 원래값으로 ㅇㅇ

* 1학년 (5557)
    * 문제의 조건이 중요 (음수를 배우지 않음, 0 이상 20 이하)
    * `D[i][j]` = i번째까지 사용해서 j를 만드는 방법의 수
        * `D[i-1][j-A[i]] + D[i-1][j+A[i]]`
    
#### 그래프 2
* DAG? Directed Acycllic Graph
    * 사이클이 없는 방향 있는 그래프
    * 게임에서는 스킬 트리가 이런 형태임 (아니면 건물 짓는 트리라던가..)

* 위상 정렬
    * 어떤 일을 하는 순서를 찾는 알고리즘
    * BFS를 이용함 (BFS랑 비슷하지만 다름)
        * in-degree가 0이 될 때 큐에 넣는다는 차이가 있음
        * 3 이전에 1이랑 2라는 선행작업이 있을 때, 1이랑 2를 모두 방문한 상태여야만 3을 방문할 수 있음 (둘중 하나만 방문한 상태에서는 안됨)
    * DAG에서 in-degree가 0인 정점이 반드시 존재하는가?
        * 그렇다. 그렇지 않은 경우 싸이클이 있다는 것이므로 DAG의 조건에 맞지 않는다.
    * check 배열을 필요로 하지 않음.
    * 위상 정렬의 시간복잡도는? O(V+E)
        * 큐에 언제 들어가냐를 빼고는 BFS랑 똑같은 수준이라...
    * 문제는 특별한 경우를 빼고는 보통 답 중에서 제일 앞서는 (사전순으로?) 것을 출력하라는 식으로.. (아니면 가능한 경우가 한가지라거나)
    * 우선순위 큐 (힙)
        * 자바에서는 priorityQueue 사용
    * 위상 정렬은 응용이 별로 많지 않다. 주로 순서 구할 때 씀.

* 작업 (2056)
    * 위상 정렬로는 이 문제를 풀 수 있음.
    * 가장 오래 걸리는 작업이 끝나야 다음껄로 갈 수 있다는 걸 고려

* 모든 DP 문제를 그리면 DAG가 나온다?

* MST? Minimum Spanning Tree
    * 스패닝 트리 : 그래프에서 일부 간선을 선택해서 만든 트리
    * 최소 스패닝 트리 : 스패닝 트리 중에서 가중치의 합이 최소가 되는 트리
    * 그래프에서 나올 수 있는 스패닝 트리의 개수를 구할 수 있는 법도 있는데.. 어렵다. (공식이 있음)
        * [9614번 문제](https://icpc.me/9614)
    * 스패닝 트리 구하는건 별로 중요하지 않지만 MST 구하는 문제는 매우 중요하다.
    * 프림 / 크루스칼 방법
        * 프림은 정점 기준, 크루스칼은 간선 기준

* 프림
    * 정점을 점점 추가하면서 MST를 만들어나감
    * 선택한 정점과 선택하지 않은 정점을 연결하는 간선중에 최소값을 고름
    * 그리디 알고리즘이라고 할 수 있음
    * 힙을 사용
        * 힙에 (정점, 가중치) 넣어주기
    * 시간복잡도는? O (E lg E)
    * 다익스트라와 비슷하다고도 볼 수 있음

* 유니온 파인드 (너무 생소한 개념이라 따로 찾아서 공부해야할듯)
    * 상호 배타적 집합
    * 트리를 이용해서 구현
    * find는 재귀 함수로 구현

* 크루스칼
    * 가중치 작은 간선부터 살펴봄
    * 서로 다른 집합이면 합치기 (연결)
        * 같은 집합이면 연결했을 때 사이클이 발생하므로 스킵
    * 유니온 파인드를 이용한 알고리즘임
    * O (E lg E)
    * 프림보다 코드가 훨씬 간단함

* 최단 경로
    * 벨만포드 : 가중치에 음수 O
        * 네트워크 플로우 (MCMF)
    * 다익스트라 (제일 빠름) : 음수 X
    * 플로이드-와샬 
    * 이 세가지의 역할이 모두 다름
        * 벨만포드, 다익스트라는 시작점이 하나
        * 플로이드-와샬은 시작점이 V개
    * BFS랑 다익스트라만 알아도 거의 대부분은 구할 수 있음.
        * BFS의 경우 가중치가 0이나 1인 경우
    * A에서 B로 가는 최단 경로 사이에 A나 B는 등장하지 않는다.
        * 최대 V-1개의 간선
    
    * 벨만포드
        * 모든 간선에 대해서 한번씩 검사 (V-1번 반복)
        * O(VE)
        * 다익스트라보다 느림, 음수 가중치가 존재하는 그래프는 잘 없어서 별로 쓸일이 없는 알고리즘
    
    * 다익스트라
        * check 배열에 방문 여부를 기록함 (따라서 배열이 두개 필요)
        * 정점 선택을 V번 해봄, 한 정점을 선택하는데 V라는 시간이 걸림
            * 시간복잡도는 O(V^2)
        * 최단 거리를 구하지 않은 상태에서 모든 dist를 무한대로 세팅
        