## 3회차
* 완전 탐색
완전 탐색이란? 그냥 알고리즘 컨셉을 하나의 이름으로 묶어놓은것일뿐..
- 브루트 포스
    - 모든 경우의 수를 다 해봄.
    - 비효율적인데 왜 쓰냐?
        - 경우의 수가 적은 경우에는 이 방법으로 시간내로 구할 수 있음.
        - 100만번 연산쯤이야 컴퓨터로는 1초내로!

- 비트마스크 (bitmask)
    - 2^n
- 재귀호출 (recursion)
    
- 순열 (permutation)
    - n!
- BFS
    - 그래프때랑은 성격이 다르지만, 다 해보면서 최소비용 찾기

* 첫번째 단계
    - 전체 경우의 수를 다 구하고 시작하자! (코딩하기 전에)
    - 몇 개 정도까지 이 방법으로 해결 가능한가? 를 탐색
    
* 그냥 다 해보기
    - 일곱 난쟁이 (2309)
        - 7중 for문으로 구해도 되지만 그럴 필요가 없다. 두명 골라낸다고 생각하면 훨씬 빠르게 구함.
    - 날짜 계산 (1476)
        - 경우의 수가 15 * 28 * 19라서 그냥 다 구해보면 됨
        - 중국인의 나머지 정리라는 방법을 쓸 수도 있음
    - 리모컨 (1107)
        - 최소값 구하는 문제에는 여러가지 등장하는 성질이 있다.
            - 같은 곳을 여러번 가는거는 의미가 없다. (한번만 가거나 안가거나)
            - 불필요한 것을 하지 않는다. (A에서 B를 가야하는데 굳이 C를 거칠 필요가 없음)
        - 1) 숫자 버튼을 무조건 먼저 눌러야된다.
        - 2) 다시 같은 위치로 돌아오는 동작은 정답이 될 수 없다.
            - 예를 들어서 `+++-+-+`
            - 그러므로 +나 -중 하나만 누르면 된다.

* N중 for문
    - 1,2,3 구하기의 경우의 수는 사실 3의 10제곱임. 10중 for문으로 가능.
    - 실제로 문제 풀때는 안씀 (재귀함수라는 대체제도 있고...)

* 순열
    - 크기가 N인 순열은 총 N!개
    - 순열에 각각 순서를 정할 수 있다. (첫 순열부터 다음 순열로 내려가면서 마지막까지 조사하는 식으로 이용)
    - 오름차순 정렬로 첫 순열 만들고 그다음 쭉 진행하면 된다.
    - C++에는 next_permutation 같은 애들이 STL에 정의되어있다.
        - 이외의 언어는? 없음.. 직접 구현해야됨
    - 슬라이드에 있는 코드는 왜 bool형 함수인가?
        - 마지막 순열인 경우 false, 아닌 경우 true를 반환함
    - 차이를 최대로 (10819)
        - N 제한이 8이라 그냥 8! 밖에 안됨
        - 다해봐도 됨!
    - 외판원 순회 (10971)
        - TSP라고 부르는 아주 유명한 문제
        - N 제한이 10이라 모든 경우 다 해볼 수 있음 (10! = 3628800)
        - 원래는 O(N*N!)이지만 문제의 특성을 이용해서 O(N!)으로 줄이기 가능
            - 시작 도시 1번으로 고정하고 계산해도 나머지 도시를 시작 도시로 하는거랑 차이가 없음
        - DP로 풀기 가능 (외판원 순회 1은 N 제한이 16이라 이렇게 해야됨)
    - 문제를 읽어보니까 순서에 대한 내용이 나오면 순열 문제임 (대부분)

* 비트마스크
    - 부분 집합 표현
    - 문제 풀이보다는 다른걸 만들때 많이 씀
    - 배열의 인덱스로 집합을 넣을 수 있다는 장점이 있음!
    - 부분 집합의 합 (1182)
        - N 제한이 20인데, 2^20은 1048576임
        - 복잡도는 N * 2^N
    - 종이 조각 (14391)
        - 가로 세로 상태값을 비트로 저장하고 각각 해봐서 최대값 구하기
        - 직접 풀어봐야될듯
    
* 큐 사용하기 (BFS)
    - 최소값, 모든 가중치가 1, 상태의 개수 적을 때
    - BFS에서는 상태가 정점이 됨
    - DP는 문제가 갈수록 작아진다는 특징이 있고, BFS는 조금 다름
    - 이 경우에도 BFS는 똑같이 구현을 함
    ```
    Queue에 시작 지점 Push
    while(Queue 비어있지 않은 동안)
        Queue에서 하나 뺌
        ...
        ...
    ```
    - 숨바꼭질 (1697, 13913)
        - 역추적 방식으로..
    - DSLR (9019)
    - 퍼즐 (1525)

    과제 : 풀이를 읽지말고 이모티콘(14226) 문제를 풀어보세요. 시간이 남으면 DP로도 해보세요.