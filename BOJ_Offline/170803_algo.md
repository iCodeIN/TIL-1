## 10회차

#### 문자열
1. 문자열 S에서 패턴 P를 찾음 -> KMP
2. 문자열 N개 중에서 문자열 S를 찾음 -> Trie
3. 문자열 N개 중에서 패턴 P를 찾음 -> 1+2 (Aho-corasick)

* Trie
    * 문자열의 비교는 숫자보다 오래걸림 -> O(길이)
    * Trie는 Prefix Tree로도 부름
    * 처음에는 글자가 없는 빈 노드가 있고 (Root) 이후 한글자씩 붙어서 노드가 추가됨
        * `"" - a - ab - abc`
    * 트리의 Depth는 문자열의 길이와 같음
    * 알파벳 개수인 26개에 맞춰서 children 노드를 미리 생성
    (-1로 초기화)
    
    * 전화번호 목록 (5052)
        * 접두어 성질 이용해서 전화번호부 일관성 확인
    
    * 두 수 XOR (13505)
        * 두수 XOR한 값이 가장 큰 것을 찾기
        * 수를 Trie에 집어넣고 XOR
        * 1부터 N까지의 정수가 N+1개 있고 2개 있는 숫자가 딱 하나 있을 때, 그걸 찾는 좋은 방법은 XOR
            * 같은 수끼리 XOR하면 모든 비트가 같아서 0이 나오는 것을 이용

    * XOR 합 (13504)
        * 두수 XOR과 비슷하게 품
    
    * prefix가 별로 겹치지 않으면, Trie는 비효율적이게 됨.
        * C++는 `Set<String>`, Java는 `HashSet<String>`
        * 그럼 왜 Trie를 쓰냐?
            * Aho-corasick

* Aho-corasick
    * Trie에 KMP의 pi를 구현
    * `pi[node]` : node가 나타내는 문자열 s의 suffix이면서 Trie에 포함된 가장 긴 문자열
    * BFS를 이용
    * 용도 : 문자열 N개 중에서 패턴 P를 찾음 -> 그 외에는 잘 안쓰임

#### DP 3
* 상태 다이나믹
    * 블럭을 놓는 문제가 있으면 블럭이 있고 없고에 대해..
    * 타일채우기 (2133)
        * 어떤 칸을 채울 때, 그 앞줄에 올 수 있는 경우의 수가 8개임
        * 각 경우의 수에 대해 앞에 올 수 있는 가짓수 계산
            * 예시 : 0번 상태(세칸 다 비어있음)에서 채울 때, 그 앞줄까지는 모두 채워져 있어야 하므로 무조건 7번(세칸 다 채워짐) 상태가 있어야함. (슬라이드 참조)
        * 정답은 어디에? `D[n][7]`
        * 3 X n이 아니고 4 X n이면? 2^4 = 16개의 상태 존재. 똑같이 나열해서 풀어보면 됨
    
#### 세그먼트 트리 활용하기
* 가장 긴 증가하는 부분 수열 2 (12015)
    * 세그먼트 트리로 풀 수도 있는 문제
    * tree 배열에는 해당 수를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이가 들어감
        * `tree[i]` : 수 i를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이
    * O(n log n)
    * 각각의 수마다 세그먼트 트리 업데이트를 한번씩 해야함

* 가장 긴 증가하는 부분 수열 3 (12738)
    * 수의 범위가 너무 크지만 실제로 그 수가 필요한게 아님
    * 수를 압축함 (각 수의 높이가 구별될 정도로)

* 공장 (7578)
    * 교차의 개수 세기

* 순열 (1849)
    * 주어진 `a[i]`를 보고 세그먼트 트리에 넣어가며 원래 순열 찾기
    
* 조세퍼스 문제 (1168)
    * 세그먼트 트리로 할 수 있다 (위치 찾는거)