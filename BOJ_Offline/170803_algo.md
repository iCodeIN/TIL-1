## 10회차

#### 문자열
1. 문자열 S에서 패턴 P를 찾음 -> KMP
2. 문자열 N개 중에서 문자열 S를 찾음 -> Trie
3. 문자열 N개 중에서 패턴 P를 찾음 -> 1+2 (Aho-corasick)

* Trie
    * 문자열의 비교는 숫자보다 오래걸림 -> O(길이)
    * Trie는 Prefix Tree로도 부름
    * 처음에는 글자가 없는 빈 노드가 있고 (Root) 이후 한글자씩 붙어서 노드가 추가됨
        * `"" - a - ab - abc`
    * 트리의 Depth는 문자열의 길이와 같음
    * 알파벳 개수인 26개에 맞춰서 children 노드를 미리 생성
    (-1로 초기화)
    
    * 전화번호 목록 (5052)
        * 접두어 성질 이용해서 전화번호부 일관성 확인
    
    * 두 수 XOR (13505)
        * 두수 XOR한 값이 가장 큰 것을 찾기
        * 수를 Trie에 집어넣고 XOR
        * 1부터 N까지의 정수가 N+1개 있고 2개 있는 숫자가 딱 하나 있을 때, 그걸 찾는 좋은 방법은 XOR
            * 같은 수끼리 XOR하면 모든 비트가 같아서 0이 나오는 것을 이용

    * XOR 합 (13504)
        * 두수 XOR과 비슷하게 품
    
    * prefix가 별로 겹치지 않으면, Trie는 비효율적이게 됨.
        * C++는 `Set<String>`, Java는 `HashSet<String>`
        * 그럼 왜 Trie를 쓰냐?
            * Aho-corasick

* Aho-corasick
    * Trie에 KMP의 pi를 구현
    * `pi[node]` : node가 나타내는 문자열 s의 suffix이면서 Trie에 포함된 가장 긴 문자열
    * BFS를 이용
    * 용도 : 문자열 N개 중에서 패턴 P를 찾음 -> 그 외에는 잘 안쓰임

#### DP 3
* 상태 다이나믹
    * 블럭을 놓는 문제가 있으면 블럭이 있고 없고에 대해..
    * 타일채우기 (2133)
        * 어떤 칸을 채울 때, 그 앞줄에 올 수 있는 경우의 수가 8개임
        * 각 경우의 수에 대해 앞에 올 수 있는 가짓수 계산
            * 예시 : 0번 상태(세칸 다 비어있음)에서 채울 때, 그 앞줄까지는 모두 채워져 있어야 하므로 무조건 7번(세칸 다 채워짐) 상태가 있어야함. (슬라이드 참조)
        * 정답은 어디에? `D[n][7]`
        * 3 X n이 아니고 4 X n이면? 2^4 = 16개의 상태 존재. 똑같이 나열해서 풀어보면 됨
    
#### 세그먼트 트리 활용하기
