## 9회차

#### RMQ (Range Minimum Query)
* 구간의 최소값 구하기!
    * `A[0] ~ A[10]`까지 있는 배열이 있다고 쳤을 때 특정 구간의 최소값을 찾아 출력하기
    * 이러한 연산(쿼리)이 여러번 주어지는 문제

* 해결하는 법
    * 그냥 다해보기 : 구간별로 일일히 for문 돌려서 최소값 찾기
        * O(MN) : 한개의 쿼리를 구하는 시간이 O(N), 쿼리의 개수 M개
        * 선처리하는데 걸리는 시간은 없음
    * 일반적으로 Preprocessing (선처리), Query (쿼리) 단계를 거쳐서 선처리 하는 시간 + 쿼리 처리 시간이 걸림.
    * 저장하기
    * 루트N으로 나누기 (sqrt decomposition)
        * 0부터 10까지 11개 있다고 했을 때, Root 11 = 3.xxx..
        * 4개의 그룹에 각각 그룹에 속한 3개의 최소값을 저장
        * 최소값을 구하는 쿼리는 두가지임
            * i와 j가 같은 그룹인 경우 -> O(Root N)
                * 쭉 훑어보면 됨
            * 다른 그룹인 경우 -> O(3 Root N)
        * 선처리 하는 시간이 O(N), 쿼리당 걸리는 시간이 O(Root N)
        * 그룹의 크기를 굳이 Root N으로 안해도 됨.
        * 더 빠른 방법이 있어서 얘를 쓸 일은 별로 없음.
    * DP
        * `D[i][j] = A[i]부터 2^j개의 최소값`
        * `D[i][j] = min(D[i][j-1], D[i+(1<<(j-1))][j-1]))`
        * 공간 O(N log N), 선처리 O(N log N), 최소값 구하는 시간 O(log N)
            * 선처리는 루트N 기법보다 느리지만, 최소값 구하는 시간(쿼리를 처리하는 시간)이 빠르다.
        * 사용하는 일이 거의 없음.
        * LCA가 이거랑 비슷하다.
    * 세그먼트 트리
        * 제일 많이 쓰이고, 제일 유명함!
        * 앞에서의 DP 기법은 값을 변경할 수 없는데 얘는 가능
        * 그리고 코드가 어렵지 않아서 일반적으로 얘를 많이 씀
        * 왼쪽 절반과 오른쪽 절반의 최소값 구하기
        * 배열로 구현가능
            * 트리의 depth가 거의 고정됨
            * Node는 3개의 정수로 구성
                * node : 배열 방
                * start : 시작 구간
                * end : 끝 구간
            * 예시
            ```
            n, s, e가 루트일때
            왼쪽 자식은 n*2, s, (s+e/2)
            오른쪽 자식은 n*2+1, (s+e/2)+1, e
            ```
        * 공간 O(N log N), 전처리 O(N log N), 쿼리당 걸리는 시간 O(log N)
        * 최소값 구하기 말고도 용도가 다양함. 최대값 구할 수도 있고 합도 구할 수도 있고 곱하기도 구할 수 있고.. 여튼 구간별로 해야되는 연산에 대해서는 다 할 수 있음

        * 세그먼트 트리 변경
            * 해당 값이 포함된 구간만 변경하면 됨
            * O(log N)
        * 세그먼트 트리를 써서 푸는 문제는?
            * 누가 봐도 쿼리 문제
            * 별로 그렇게 보이지는 않지만 쿼리 문제로 풀어서 해결할 수 있는 경우..
#### 누적합
* 구간의 합
    * 2차원일 때
        * 교집합의 원리를 이용
        * 3차원일 때도 가능
* 펜윅 트리 (바이너리 인덱스드 트리)
    * [참고 링크](https://www.acmicpc.net/blog/view/21)
    * i의 마지막 비트 : i를 2진수로 나타냈을 때 가장 마지막 1이 나타내는 값
        * 마지막 비트 구하는데 Log N
    * 세그먼트 트리의 비재귀 구현을 한국 블로그에서 인덱스 트리라고 부르는데, 펜윅 트리를 의미하는 것이 절대 아님!
    * 합을 구할 때는 주로 펜윅 트리를 쓰지만, 세그먼트 트리 쓸 수도 있음
        * 둘다 알아두면 좋음
    * 선처리가 없음
    * 2차원 펜윅 트리
        * 1차원을 2차원으로 확장
        * 1차원 펜윅 트리에 있는 각각의 칸에 펜윅 트리가 또 있는 구조

#### 문자열 알고리즘
* 문자열 매칭
    * 문자열 S에서 패턴 P 찾기
    * 우리가 흔히 쓰는 Ctrl+F 기능 생각하면 됨
    
* KMP
    * pi배열을 이용하는 기법
    * pi가 뭐임? (`pi[i]`)
        * P의 i까지 부분 문자열에서 prefix == suffix가 될 수 있는 부분 문자열 중에서 가장 긴 것의 길이
        * prefix가 i까지 부분 문자열과 같으면 안됨
        * 예시
        ```
        ABCAB에서 pi[4]는 2
        이유 : 앞 AB랑 뒤 AB랑 같으니까 길이인 2가 들어감
        ```
        * 재귀적으로 처리해줘야 하는 과정이 중요함
            * ABACABAB일 때 맨끝 `pi[7]`에 0이 들어가면 안된다. 어떻게 해야 0을 안넣고 올바르게 2를 넣는가?
            ```c++
            while (j>0 && p[i] != p[j]) {
                j = pi[j-1];
            }
            ```
    * JMBook에서는 백준식 pi구하기랑 다른 방법으로 구하고 있다.
    * 인터넷에 설명되어있는 자료는 백준식 pi구하기랑 값이 1씩 차이남
        * 정통식 KMP는 인덱스로 들어감. `pi[0]`에 -1 들어가고 그럼.
        * 문제를 풀 때는 인덱스보다 길이로 쓰는게 편함.
    * `pi[4] = 2`라는 것은 `p[0...1] == p[3...4]` 라는 것을 의미함
    * 얼핏보면 다 해보는거랑 같지만, 굳이 안해봐도 되는 부분을 스킵하는 것이 KMP의 특징
    * pi 구하는데 O(M), 문자열 매칭 O(N+M)

    * 광고 (1305)
        * 광고 문구가 옆으로 움직이는 광고판에서 현재 보여지고 있는 문구가 주어졌을 때, 가능한 광고의 길이 중 가장 짧은 것 구하기
            * `N - pi[N]`
    * Cubeditor (1701)
        * 소문자 5천개 이하로 구성된 문자열 S
        * S의 부분 문자열은 연속된 일부분
        * 두 번 이상 등장하는 부분 문자열 중에서 가장 긴 것의 길이는?
    * 13432번 도전해보기!

* 숙제
    * 세그먼트 응용하기 슬라이드에 있는 문제들 읽어오기