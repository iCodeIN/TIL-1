## 4회차

* 퍼즐
    * 가장 오래걸리는 (최소 이동 횟수가 가장 큰) 퍼즐의 상태를 구하고자 한다면?
        * 제일 쉬운 방법 : 모든 상태에 대해서 풀어보기

* 이모티콘
    첫번째 중요한거는 이모티콘의 개수
    
    상태를 고려해보면, 이모티콘 5개 / 클립보드 3개랑 이모티콘 5개 / 클립보드 4개는 다른 상태다.
    
    클립보드에 내용에 따라 붙여넣은 뒤 만들어지는 개수가 다르기 때문에
    
    (이모티콘 s, 클립보드 c)
    
    그럼 처음 시작 상태는? (1, 0)
    
    -> 내가 푸는데 실패한 이유가 뭔지 알았다. 복사를 붙여넣기랑 묶어서 생각하려고 했고 dist를 일차원적으로 생각해서.. 최소값이 들어가지 못함

    BFS는 배열이 두개 필요했다.
    
    1 체크용 2 거리 재기용
    
    그런데 이걸 하나로도 구현할 수 있다.
    
    `dist[][] == -1` 로 초기화하고 시작, `dist[1][0] == 1` 해주고 시작
    
    경계값 검사도 잘해주고 ㅇㅇ

    조건문 순서도 중요함. 왜냐면 if 조건이 두개일때 앞에꺼가 false면 뒤에꺼는 검사하지 않고 스킵하기 때문.

#### 재귀 호출
* 1,2,3 더하기 (9095)
    * 재귀 함수의 구성?
        * 정답을 찾은 경우
        * 불가능한 경우
        * 다음 경우 호출

Top-Down? 재귀함수. DP를 재귀로 푼다던가.
그런데 DP의 경우 위의 케이스에서 '메모이제이션'이 추가됨.

go (count, sum, goal) -> 숫자 count개로 합 sum 만드는 경우의 수

* 암호 만들기 (1759)
    * 재귀로 가능

go (n, alpha, password, i)

* N-Queen (9663)
    * DP로 못풀고 재귀로 해야됨
    * 행에 대해서 검사할 필요가 없다. (한 행에 하나만 있는 것이 보장되어있음)
    * 배열을 이용하면 O(1)에 검사 가능

* 스도쿠 (2580)
    * 백트래킹 문제..
    -> 이미 풀었었음

* 알파벳 (1987)
    * go (board, check, x, y, cnt)
    * DP는 공간이 너무 많이 필요 (20 * 20 * 2^26)
    * check에 방문한거 true 넣고 재귀 해주고, 다시 false로

* 로또 (6603)

* 부분집합의 합 (1182)

#### Two Pointer
* 수들의 합 2 (2003)
    * i랑 j를 놓고 i를 증가하거나 j를 증가하는 식으로
    
* 외국 사람중에 이런걸 투 포인터라고 하는 사람이 있는데, 한국에서는 꿈틀꿈틀이라고 하는 사람도 있고 자벌레라고 하기도 하고.. 간혹가다가 슬라이딩 윈도우라고 하는 경우가 있는데 이건 아니다 (슬라이딩 윈도우라는 알고리즘은 따로 있음)

* 모든 수가 양수라는 제한이 있어야함 (0과 음수 있으면 다른 방법 써야댐)

#### 그 외

* 숨바꼭질 3 (13549)
    * 0초 큐, 1초 큐..
    * 현재 큐 / 다음 큐로 2개의 큐가 필요
        * 덱을 써서 한개로 처리도 가능 (앞으로는 0 넣고 뒤로는 1 넣고)

* 알고스팟 (1261)
    * 벽을 부수는 횟수의 최소값은?

* 숨바꼭질 2 (12851)

* 벽 부수고 이동하기 (2206)
    * 미로 탐색이랑 똑같지만 딱 한번 부수기 가능
    * 기존에 상태를 i, j페어로 관리했다고 하면 이 문제는 i, j, k 구성으로 (벽 부순 횟수를 k)
    
사실 2주동안 강의 하면서 상태를 정의하는 일만 했다고 봐도 된다. (DP가 됐든 BFS가 됐든)

이게 아주 중요한 것이다.

* 중간에서 만나기
    * 절반으로 나눠서 복잡도 줄이기!

* 부분 집합의 합 2 (1208)
    * 배열을 두개 쓰고, two pointer 하듯이 하나씩 당기면서 각각의 경우를 나열
    * 중간에서 만나기 방법을 쓰는 문제임!
    
* 합이 0인 네 정수 (7453)
    * a+b+c+d = 0이니까 a+b = -(c+d) 인 경우를 구해야댐

가짓수가 너무 많은데 반으로 쪼갠뒤에 합칠 수 있으면 이 방법을 씀
