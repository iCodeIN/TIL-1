```
이번 챕터에서 얘기하려는 것은 크게 두가지로 나눌 수 있어요

인터넷이 과연 어떻게 생겼냐는거랑 프로토콜의 개념
이번 시간에는 주로 프로토콜에 대해 살펴볼거에요

일단 네트워크의 퍼포먼스를 얘기할 때 딜레이, 로스, throughput 를 빼놓을 수 없는데 이 세가지 메트릭을 중요하게 봅니다

우선 딜레이부터 살펴봅시다

어떤 패킷이 한 hop을 지나가는데 있어서 겪게되는 딜레이는 네가지 종류가 있어요

어떤 패킷이 어떤 노드에 도착하면 프로세싱을 하게 되어요 각종 프로세싱을 하지만 주요적인걸 꼽으면 오류없이 잘 왔나 (한홉을 잘 건너왔나) 에러체킹을 하게 되어요
그다음에 어느 링크로 뽑아줘야할건가 아웃풋 링크를 결정해줘야해요
최소한 이런 두가지 일 해줘야해요
이거 이외에도 네트웍 종류 프로토콜 종류에 따라 또 있을수 있지만 이런 프로세싱을 해줘야한다는거 도착한 패킷에 대해서

이런 모달 프로세싱은 보통 밀리시컨드보다 작은 디레이가 필요하고

아웃고잉 링크 결정되고 나면 패킷스위치 네트워크에서는 이 아웃고잉 링크가 어베일러블 하지 않을 수 있죠
그래서 일다 ᆫ이 아웃고잉 링크로 실려나갈 수 있는 큐 버퍼에 들어가게되요

그래서 그 버ㅓㅍ에서 아웃고잉 링크가 자기 차례될때까지 기다리게 되죠
이버퍼에서 아웃고잉 링크가 자기 차례 될때까지 기다리는 시간을 큐잉디레이라고 하죠

이 큐잉딜리에는 그 노드의 컨제스쳔 복잡한 정도에 따라서 달라지게 되죠 가변적

이 노달 프로세싱 딜레이 같은 경우는 일반적으로 각 패킷이 들어있을때 해주게 되는 일이 매우 유사하고 그다음에 그 한 노드에서 매우 고정적인데 반해서 이거는 어때요
큐잉딜레이는 가변적일 수 있어요 그때 그 노드의 컨제스쳔이 얼마나 심하냐에 따라서 큐잉딜레이가 달라질 수 있어요

이제 노드에 도착해서 프로세싱을 해서 아웃고잉링크가 결정되어서 그 링크에서 그 아웃고잉링크로 뽑히기 위한 큐에서 기달려서 드디어 차례가 됐어요 링크에 실릴 차례

그럼 어때요? 링크에 밀어넣는 시간이 필요하고 이것을 트랜스미션딜레이라고 해요

이 트랜스미션딜레이는 패킷의 크기와 ㅣㄹ크의 밴드위스에 의해서 결정

패킷의 크기가 거의 일정하고 링크의 밴드위스자체가 이 노드에서는 이미 결정되어있기 때문에 트랜스미션 딜레이도 거의 일정해요
트랜스미션 딜레이는 패킷이 길면 길수록 오래 밀어넣게 되어서 더욱 길어지고 밴드위스가 커질수록 즉 단위시간당 밴드위스가 뭐죠 밀어넣는 속도죠 비트를 링크에 밀어넣는 속도
밴드위스가 크면 클수록 어때요? 짧아져요

d trans = L / R

그다음에 propagation delay는 비트가 링크에 실렸어요 그렇다고 다음번 노드에 바로 도달하게 될까요? 아니에요 그쵸 왜냐면 트랜스미션 링크를 타고 프라퍼게이트가 되어야해요
링크의 길이가 있고 그다음에 이 링크상에서 일렉트로닉 시그널이 전파되는 속도가 있을 때 링크의 길이 나누기 전파속도 해서 이 프라퍼게이션 딜레이가 결정되겠죠
일반적ㅡㅇ로 그 일트로닉 시글널이 가이디드 미디엄을 통해서 전파되는 속도는 이곱하기 십의 팔승 미터퍼 세컨드
그러니까 링크의 길이 나누기 이 프라퍼게이션 스피드 한것이 딜레기아 되어요

한 노드를 통과하게 위해서 패킷은 프로세싱되어야하고 아웃고잉 링크가 정해져서 큐에 대기해야되고 트랜스미트되어야하고 그다음에 프라퍼게이트해야해서 배달을 하게 되는거죠

이 네가지 종류의 딜레이가 한 홉을 지나가기 위해서 겪어야하는 딜레이가 되어요
이중에 가변적인건? 큐잉 딜레이밖에 없죠

큐잉딜레이에 대해서 조금 더 살펴보면 큐잉 딜레이가 왜 발생하게 될까요? 결국 여기서 뽑아낼 수 있는 속도보다 더 빠른 속도로 트래픽이 유입되기 때문에 버퍼에 패킷들이 쌓이고 되는거고 딜레이가 그 버퍼에서 대기하는 큐잉딜레이가 발생하게 되는거겠죠

이걸 우리ㅏ가 좀 더 자세히 살펴보면 이 노드에 유입되는 양은 어떻게 결정이 되냐면 La / R
(L * a = 단위시간당 유입되는 트래픽의 양)
R : link bandwidth(bps)
L : packet length(bits)
a : average packet arrival rate

traffic intensity = La/R

만약에 La랑 R이랑 똑같다는건 어떤 의미일까요? 유입되는 속도랑 뽑아내는 속도가 같다는거에요
La/R ~ 0: avg. queueing delay small
La/R > 1: avg. queueing delay large
La/R > 1: more "work" arriving
than can be serviced, average delay infinite!

큐잉딜레이는 트래픽의 유입속도와 밴드위스의 비율에 의해서 결정이 된다는거에요

두번째 메트릭 packet loss에 대해 살펴봅시다

아웃고잉링크마다 어때요? 그 아웃고잉링크가 바로 어베일러블하지 않을때 대기하는 큐가 있게되요
근데 그 큐의 사이즈는 어떨까요 이게 컴퓨터시스템이기 때문에 파이나이트일수밖에 없어요

아까 봤을때 이 트래픽 인텐서티 La / R이 1에 근접하게 되면 큐가 점점 길어지겠죠
그래서 경우에 따라서는 큐가 꽉찰수도 있어요 그쵸
그럴때 피킷이 도착하면 버릴수밖에 없죠 큐에 저장할수 없으니가
로스가 발생하게 되요
이 로스가 발생하게 되면 사용자 입장에서는 딜레이가 매우 길어지게 되고
네트웍의 입장에서 보면 리소스 낭비하게 되요
애ㅗ냐면 지금까지 배달하기 위해서 사용한 네트워 리소스는 그 패킷이 중간에 드랍되기 때문에 낭비된거자나요

마지막으로 세번째 퍼포먼스 메트릭은 트루풋이에요

단위시간당 처리량

네트웍에서의 트루풋은 단위시간당 소스로부터 데스티네이션까지 배달한 트래픽의 양이에요

자 여기 서버가 있고 여러분의 호스트가 있어요 그럴때 여러분이 여기서 어떤 웹페이ㅈ ㅣ리퀘스트에서

서버에서 웹페이지를 여기로 보낸다고 합니다 서버는 네트웍의 이 링크에 의해서 연결되어이고
여러분의 호스트는 이런 링크에 의해서 네트워에 연결되어있다고 합니다

server, with file of F bits to send to client -> (link capacity Rs bits/sec) -> (link capacity Rc bits/sec) -> client(PC)

이 링크의 캐퍼시티는 Rs bits/sec이고 저 링크의 캐퍼시티는 Rc bits/sec라고 합니다

둘이 다른데 어느쪽이 더 큰거죠? Rc가 더 큰거죠

패킷스위칭 네트웍에서는 패킷 하나 다 배달될때까지 다음 패킷을 이후에 전송을 안해요
그렇기 때문에 연결된 파이프라고 보기 힘든데... 이렇게 생각할 수 있어요

패킷 단위로 생각해보세요 첫번째 패킷이 도착을 했어요 그리고 첫번째 패킷이 이쪽으로 가고 있는동안 두번째 패킷은 어때요 

이쪽으로 오고 있을 수 있어요 그쵸 그러니까 어때요 마치 여러분이 병렬처리에서 본것처럼 파이프라이닝이 이루어질 수 있는거에요
패킷전송의 파이프라이닝
즉 얘네들을 파이프로 볼 수 있는거에요

결국 단위시간당 여기서 여기로 전달되는 양은 어떤 파이프에 의해서 결정되는걸까요? 더 가는파이프
커패서티가 작은 링크에 의해서 결정되는거에요

* Throughput (more)
- Rs < Rc What is average end-end throughput?
Rs에 의해 결정
- Rs > Rc What is average end-end throughput?
Rc에 의해 결정

소스에서 데스티네이션 가기까지 여러가지 링크들이 있을 수 있는데 그 링크중에 어때요 제일 커패서티가 작은 링크에 의해서 엔드 투 엔드 트루풋이 결정되는거에요

그런걸 바로 보틀넥 링크라고 하는거에요

(일반적인 인터넷 환경에 대해 설명, Chapter1 슬라이드 기준 54p)
일반적인 환경에서 보틀넥은 엣지쪽에 발생하는일이 대부분

이제 프로토콜의 개념을 살펴보도록 합시다

프로토콜은 레이어링 구조를 가지고 있어요 레이어링 구조로 정의되어 있는데 그 이유는 이 프로토콜이 매우 복잡한 시스템이기 때문에 그래요
방대하고 복잡한... 이 방대하고 복잡한 시스템을 레이어링이라는 구조로 디파인을 하면 좋은점도 있고 하지만 나쁜점도 있어요
조은점은 뭐냐면 일단 그 컴플렉스한 시스템의 각 피스를 아이덴티파이하고 그들간의 관계를 정의하는것이 매우 용이해져요
레어이링으로 모듈러라이즈 하면..

뿐만 아니라 이런 시스템을 가져다가 모듈러라이즈를 해서 구현하게 되면 메인터넌스와 업데이트가 용이하게되요

큰 방대한 프로그램을 하나의 펑션으로 구현하면 어때요? 수정하기 굉장히 힘들어지죠 그쵸
하지만 기능별로 나눠서 모듈러라이즈해서 펑션으로 분리하면 어때요 그 펑션 내부에서 아무리 변화를 줘도 다른 프로그램 코드에 영향을 안주죠 그런것처럼
이 시스템을 구현할때 모듈러라이즈를 하게 되면 메인터넌스나 업데이트가 굉장히 용이해지게 되죠
프로토콜이라는 것이 매우 방대하고 복잡한것이기 때문에 레이어링이라는 구조르 ㄹ가져요

나쁜점은 뭐냐면 그 각 레이어는 자기의 고유 목적이 있어요 그 고유 목적 때문에 어떤 기능을 실행하게 되는데 그 기능간에 굉장히 중복성이 발행할 수 있다는거에요

가령 있어서 어떤 레이어는 소스로부터 데스티네이션까지 아무 오류 없이 제대로 잘 전달해주는것이 이 레이어의ㅖ 목적이에요
다른 레이어의 목적은 한 홉을 제대로 건너가는것이 그 레이어의 목적이라고 합시다
그럼 어때요? 한 홉을 제대로 건너야하는 레이어가 다 체크할거에요 그쵸?
근데 전자(소스로부터 데스티네이션까지 ...) 도 다시 여기서부터 끝까지 다 체크를 해줘요

사실 한홉을 제대로 건너왔다면 제대로 온걸텐데... 여튼 그 기능들간에 서로 겹치는 부분이 있을 수 있다는거에요

그다음에 또 다른 단점은 뭐냐면 이 레이어 어떤 한ㄹ ㅔ이어가 옵티멀하게 작동하기 위해서는 다른 레이어에서 콜렉트하는 정보나 다른 레이어에서만 알려지게되는 그런 정보를 필요로 할수도 있어요
그럴때 이걸 엄격하게 레이어로 구별해놓으면 이 두 레이어간에 어떤 커뮤니케이션이 있어야만 다른 레이어에서 발생한 정보를 가져올 수 있겠죠
그 가져오는 오버헤드가 발생할 수 있어요

그래서 어떤 레이어의 기능을 구현하는 것이 옵티멀하지 않을 수 있다는거에요

경우에 따라서는 한 레이어에 그 정보가 여기서 어베일러블한 정보가 아주 딱 분리되어있어서 전혀 사용할 수 없을수도 있어요

사용을 한다며 ㄴ훨씬 옵티멀하게 자기 기능을 구현할 수 있음에도 불구하고 레이어의 구분 때문에 그 정보를 활용하지 못해서

옵티멀하지 못한 디시젼을 내려야할 수도 있다는거에요

어쨌거나 지금 인터넷의 모든 네트워크의 프로토콜은 계층 구조로 디파인되어있어요

인터넷 프로토콜 스택을 한번 살펴보겠어요 인터넷 프로토콜은 이렇게 다섯개의 계층으로 구성되어있어요
application
transport
network
link
physical

맨위의 애플리케이션 계층의 목적은 뭐냐면 네트워크 애플리케이션 프로그램을 지원하는거에요 그래서 가령 예를 들어
웹 애플리케이션의 경우 HTTP라는 프로토콜이 이 웹 애플리케이션 프로그램을 지원하고 있어요 어떤식으로 지원을 하냐
웹 애플리케이션이 실행되기 위해서 과연 웹페이지를 리퀘스트하는 메시지는 어떤 형태로 만들어졌고
어더형태로 생겼고 어떤 형식으로 전달되고 리퀘스트 메시지럴 받은 웹서버에서는
다시 리플라이 리스폰스를 어떤 식으로 프리페어하고 보내야 할지 이런걸 다 정의하고 있는거에요

그래서 웹 애플리케이션에서는 hTtp라는 프로토콜을 쓰고
이메일 을위해서는 smtp
파일을 위해ㅓ슨 ftp

이 애플리케이션 계층 프로토콜은 애플리케이션마다 그 애플리케이션을 지원하기 위한 그러한 프로토콜이 디파인되어있다는거에요

이 계층에서 해주는 일은 유저 애플리케이션 프로그램에서 발생시킨 데이터를 인캡슐 (포장)해서 어떻게 메시지로 만드냐가 얘의 주된 역할이에요

이 애플리케이션 계층에서 유저 메시지를 만들어내면 그다음에는 트랜스포트 계층에다가 프로세스 to 프로세스 딜리버리를 부탁해요
(소스 - 데스티네이션)
소스 프로세스는 어디에 드러앉아 있을거에요? 소스 호스트랑 데스티네이션 호스트중에서 ㅇㅇ

너무 쉬운 문제얌~ 소스 호스트에 드러앉아있는거에요



```