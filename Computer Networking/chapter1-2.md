```
이번 챕터에서 얘기하려는 것은 크게 두가지로 나눌 수 있어요

인터넷이 과연 어떻게 생겼냐는거랑 프로토콜의 개념
이번 시간에는 주로 프로토콜에 대해 살펴볼거에요

일단 네트워크의 퍼포먼스를 얘기할 때 딜레이, 로스, throughput 를 빼놓을 수 없는데 이 세가지 메트릭을 중요하게 봅니다

우선 딜레이부터 살펴봅시다

어떤 패킷이 한 hop을 지나가는데 있어서 겪게되는 딜레이는 네가지 종류가 있어요

어떤 패킷이 어떤 노드에 도착하면 프로세싱을 하게 되어요 각종 프로세싱을 하지만 주요적인걸 꼽으면 오류없이 잘 왔나 (한홉을 잘 건너왔나) 에러체킹을 하게 되어요
그다음에 어느 링크로 뽑아줘야할건가 아웃풋 링크를 결정해줘야해요
최소한 이런 두가지 일 해줘야해요
이거 이외에도 네트웍 종류 프로토콜 종류에 따라 또 있을수 있지만 이런 프로세싱을 해줘야한다는거 도착한 패킷에 대해서

이런 모달 프로세싱은 보통 밀리시컨드보다 작은 디레이가 필요하고

아웃고잉 링크 결정되고 나면 패킷스위치 네트워크에서는 이 아웃고잉 링크가 어베일러블 하지 않을 수 있죠
그래서 일다 ᆫ이 아웃고잉 링크로 실려나갈 수 있는 큐 버퍼에 들어가게되요

그래서 그 버ㅓㅍ에서 아웃고잉 링크가 자기 차례될때까지 기다리게 되죠
이버퍼에서 아웃고잉 링크가 자기 차례 될때까지 기다리는 시간을 큐잉디레이라고 하죠

이 큐잉딜리에는 그 노드의 컨제스쳔 복잡한 정도에 따라서 달라지게 되죠 가변적

이 노달 프로세싱 딜레이 같은 경우는 일반적으로 각 패킷이 들어있을때 해주게 되는 일이 매우 유사하고 그다음에 그 한 노드에서 매우 고정적인데 반해서 이거는 어때요
큐잉딜레이는 가변적일 수 있어요 그때 그 노드의 컨제스쳔이 얼마나 심하냐에 따라서 큐잉딜레이가 달라질 수 있어요

이제 노드에 도착해서 프로세싱을 해서 아웃고잉링크가 결정되어서 그 링크에서 그 아웃고잉링크로 뽑히기 위한 큐에서 기달려서 드디어 차례가 됐어요 링크에 실릴 차례

그럼 어때요? 링크에 밀어넣는 시간이 필요하고 이것을 트랜스미션딜레이라고 해요

이 트랜스미션딜레이는 패킷의 크기와 ㅣㄹ크의 밴드위스에 의해서 결정

패킷의 크기가 거의 일정하고 링크의 밴드위스자체가 이 노드에서는 이미 결정되어있기 때문에 트랜스미션 딜레이도 거의 일정해요
트랜스미션 딜레이는 패킷이 길면 길수록 오래 밀어넣게 되어서 더욱 길어지고 밴드위스가 커질수록 즉 단위시간당 밴드위스가 뭐죠 밀어넣는 속도죠 비트를 링크에 밀어넣는 속도
밴드위스가 크면 클수록 어때요? 짧아져요

d trans = L / R

그다음에 propagation delay는 비트가 링크에 실렸어요 그렇다고 다음번 노드에 바로 도달하게 될까요? 아니에요 그쵸 왜냐면 트랜스미션 링크를 타고 프라퍼게이트가 되어야해요
링크의 길이가 있고 그다음에 이 링크상에서 일렉트로닉 시그널이 전파되는 속도가 있을 때 링크의 길이 나누기 전파속도 해서 이 프라퍼게이션 딜레이가 결정되겠죠
일반적ㅡㅇ로 그 일트로닉 시글널이 가이디드 미디엄을 통해서 전파되는 속도는 이곱하기 십의 팔승 미터퍼 세컨드
그러니까 링크의 길이 나누기 이 프라퍼게이션 스피드 한것이 딜레기아 되어요

한 노드를 통과하게 위해서 패킷은 프로세싱되어야하고 아웃고잉 링크가 정해져서 큐에 대기해야되고 트랜스미트되어야하고 그다음에 프라퍼게이트해야해서 배달을 하게 되는거죠

이 네가지 종류의 딜레이가 한 홉을 지나가기 위해서 겪어야하는 딜레이가 되어요
이중에 가변적인건? 큐잉 딜레이밖에 없죠

큐잉딜레이에 대해서 조금 더 살펴보면 큐잉 딜레이가 왜 발생하게 될까요? 결국 여기서 뽑아낼 수 있는 속도보다 더 빠른 속도로 트래픽이 유입되기 때문에 버퍼에 패킷들이 쌓이고 되는거고 딜레이가 그 버퍼에서 대기하는 큐잉딜레이가 발생하게 되는거겠죠

이걸 우리ㅏ가 좀 더 자세히 살펴보면 이 노드에 유입되는 양은 어떻게 결정이 되냐면 La / R
(L * a = 단위시간당 유입되는 트래픽의 양)
R : link bandwidth(bps)
L : packet length(bits)
a : average packet arrival rate

traffic intensity = La/R

만약에 La랑 R이랑 똑같다는건 어떤 의미일까요? 유입되는 속도랑 뽑아내는 속도가 같다는거에요
La/R ~ 0: avg. queueing delay small
La/R > 1: avg. queueing delay large
La/R > 1: more "work" arriving
than can be serviced, average delay infinite!

큐잉딜레이는 트래픽의 유입속도와 밴드위스의 비율에 의해서 결정이 된다는거에요

두번째 메트릭 packet loss에 대해 살펴봅시다

아웃고잉링크마다 어때요? 그 아웃고잉링크가 바로 어베일러블하지 않을때 대기하는 큐가 있게되요
근데 그 큐의 사이즈는 어떨까요 이게 컴퓨터시스템이기 때문에 파이나이트일수밖에 없어요

아까 봤을때 이 트래픽 인텐서티 La / R이 1에 근접하게 되면 큐가 점점 길어지겠죠
그래서 경우에 따라서는 큐가 꽉찰수도 있어요 그쵸
그럴때 피킷이 도착하면 버릴수밖에 없죠 큐에 저장할수 없으니가
로스가 발생하게 되요
이 로스가 발생하게 되면 사용자 입장에서는 딜레이가 매우 길어지게 되고
네트웍의 입장에서 보면 리소스 낭비하게 되요
애ㅗ냐면 지금까지 배달하기 위해서 사용한 네트워 리소스는 그 패킷이 중간에 드랍되기 때문에 낭비된거자나요

마지막으로 세번째 퍼포먼스 메트릭은 트루풋이에요

단위시간당 처리량

네트웍에서의 트루풋은 단위시간당 소스로부터 데스티네이션까지 배달한 트래픽의 양이에요

자 여기 서버가 있고 여러분의 호스트가 있어요 그럴때 여러분이 여기서 어떤 웹페이ㅈ ㅣ리퀘스트에서

서버에서 웹페이지를 여기로 보낸다고 합니다 서버는 네트웍의 이 링크에 의해서 연결되어이고
여러분의 호스트는 이런 링크에 의해서 네트워에 연결되어있다고 합니다

server, with file of F bits to send to client -> (link capacity Rs bits/sec) -> (link capacity Rc bits/sec) -> client(PC)

이 링크의 캐퍼시티는 Rs bits/sec이고 저 링크의 캐퍼시티는 Rc bits/sec라고 합니다

둘이 다른데 어느쪽이 더 큰거죠? Rc가 더 큰거죠

패킷스위칭 네트웍에서는 패킷 하나 다 배달될때까지 다음 패킷을 이후에 전송을 안해요
그렇기 때문에 연결된 파이프라고 보기 힘든데... 이렇게 생각할 수 있어요

패킷 단위로 생각해보세요 첫번째 패킷이 도착을 했어요 그리고 첫번째 패킷이 이쪽으로 가고 있는동안 두번째 패킷은 어때요 

이쪽으로 오고 있을 수 있어요 그쵸 그러니까 어때요 마치 여러분이 병렬처리에서 본것처럼 파이프라이닝이 이루어질 수 있는거에요
패킷전송의 파이프라이닝
즉 얘네들을 파이프로 볼 수 있는거에요

결국 단위시간당 여기서 여기로 전달되는 양은 어떤 파이프에 의해서 결정되는걸까요? 더 가는파이프
커패서티가 작은 링크에 의해서 결정되는거에요

* Throughput (more)
- Rs < Rc What is average end-end throughput?
Rs에 의해 결정
- Rs > Rc What is average end-end throughput?
Rc에 의해 결정

소스에서 데스티네이션 가기까지 여러가지 링크들이 있을 수 있는데 그 링크중에 어때요 제일 커패서티가 작은 링크에 의해서 엔드 투 엔드 트루풋이 결정되는거에요

그런걸 바로 보틀넥 링크라고 하는거에요

(일반적인 인터넷 환경에 대해 설명, Chapter1 슬라이드 기준 54p)
일반적인 환경에서 보틀넥은 엣지쪽에 발생하는일이 대부분

이제 프로토콜의 개념을 살펴보도록 합시다

프로토콜은 레이어링 구조를 가지고 있어요 레이어링 구조로 정의되어 있는데 그 이유는 이 프로토콜이 매우 복잡한 시스템이기 때문에 그래요
방대하고 복잡한... 이 방대하고 복잡한 시스템을 레이어링이라는 구조로 디파인을 하면 좋은점도 있고 하지만 나쁜점도 있어요
조은점은 뭐냐면 일단 그 컴플렉스한 시스템의 각 피스를 아이덴티파이하고 그들간의 관계를 정의하는것이 매우 용이해져요
레어이링으로 모듈러라이즈 하면..

뿐만 아니라 이런 시스템을 가져다가 모듈러라이즈를 해서 구현하게 되면 메인터넌스와 업데이트가 용이하게되요

큰 방대한 프로그램을 하나의 펑션으로 구현하면 어때요? 수정하기 굉장히 힘들어지죠 그쵸
하지만 기능별로 나눠서 모듈러라이즈해서 펑션으로 분리하면 어때요 그 펑션 내부에서 아무리 변화를 줘도 다른 프로그램 코드에 영향을 안주죠 그런것처럼
이 시스템을 구현할때 모듈러라이즈를 하게 되면 메인터넌스나 업데이트가 굉장히 용이해지게 되죠
프로토콜이라는 것이 매우 방대하고 복잡한것이기 때문에 레이어링이라는 구조르 ㄹ가져요

나쁜점은 뭐냐면 그 각 레이어는 자기의 고유 목적이 있어요 그 고유 목적 때문에 어떤 기능을 실행하게 되는데 그 기능간에 굉장히 중복성이 발행할 수 있다는거에요

가령 있어서 어떤 레이어는 소스로부터 데스티네이션까지 아무 오류 없이 제대로 잘 전달해주는것이 이 레이어의ㅖ 목적이에요
다른 레이어의 목적은 한 홉을 제대로 건너가는것이 그 레이어의 목적이라고 합시다
그럼 어때요? 한 홉을 제대로 건너야하는 레이어가 다 체크할거에요 그쵸?
근데 전자(소스로부터 데스티네이션까지 ...) 도 다시 여기서부터 끝까지 다 체크를 해줘요

사실 한홉을 제대로 건너왔다면 제대로 온걸텐데... 여튼 그 기능들간에 서로 겹치는 부분이 있을 수 있다는거에요

그다음에 또 다른 단점은 뭐냐면 이 레이어 어떤 한ㄹ ㅔ이어가 옵티멀하게 작동하기 위해서는 다른 레이어에서 콜렉트하는 정보나 다른 레이어에서만 알려지게되는 그런 정보를 필요로 할수도 있어요
그럴때 이걸 엄격하게 레이어로 구별해놓으면 이 두 레이어간에 어떤 커뮤니케이션이 있어야만 다른 레이어에서 발생한 정보를 가져올 수 있겠죠
그 가져오는 오버헤드가 발생할 수 있어요

그래서 어떤 레이어의 기능을 구현하는 것이 옵티멀하지 않을 수 있다는거에요

경우에 따라서는 한 레이어에 그 정보가 여기서 어베일러블한 정보가 아주 딱 분리되어있어서 전혀 사용할 수 없을수도 있어요

사용을 한다며 ㄴ훨씬 옵티멀하게 자기 기능을 구현할 수 있음에도 불구하고 레이어의 구분 때문에 그 정보를 활용하지 못해서

옵티멀하지 못한 디시젼을 내려야할 수도 있다는거에요

어쨌거나 지금 인터넷의 모든 네트워크의 프로토콜은 계층 구조로 디파인되어있어요

인터넷 프로토콜 스택을 한번 살펴보겠어요 인터넷 프로토콜은 이렇게 다섯개의 계층으로 구성되어있어요
application
transport
network
link
physical

맨위의 애플리케이션 계층의 목적은 뭐냐면 네트워크 애플리케이션 프로그램을 지원하는거에요 그래서 가령 예를 들어
웹 애플리케이션의 경우 HTTP라는 프로토콜이 이 웹 애플리케이션 프로그램을 지원하고 있어요 어떤식으로 지원을 하냐
웹 애플리케이션이 실행되기 위해서 과연 웹페이지를 리퀘스트하는 메시지는 어떤 형태로 만들어졌고
어더형태로 생겼고 어떤 형식으로 전달되고 리퀘스트 메시지럴 받은 웹서버에서는
다시 리플라이 리스폰스를 어떤 식으로 프리페어하고 보내야 할지 이런걸 다 정의하고 있는거에요

그래서 웹 애플리케이션에서는 hTtp라는 프로토콜을 쓰고
이메일 을위해서는 smtp
파일을 위해ㅓ슨 ftp

이 애플리케이션 계층 프로토콜은 애플리케이션마다 그 애플리케이션을 지원하기 위한 그러한 프로토콜이 디파인되어있다는거에요

이 계층에서 해주는 일은 유저 애플리케이션 프로그램에서 발생시킨 데이터를 인캡슐 (포장)해서 어떻게 메시지로 만드냐가 얘의 주된 역할이에요

이 애플리케이션 계층에서 유저 메시지를 만들어내면 그다음에는 트랜스포트 계층에다가 프로세스 to 프로세스 딜리버리를 부탁해요
(소스 - 데스티네이션)
소스 프로세스는 어디에 드러앉아 있을거에요? 소스 호스트랑 데스티네이션 호스트중에서 ㅇㅇ

너무 쉬운 문제얌~ 소스 호스트에 드러앉아있는거에요

그 소스 프로세스로부터 데스티네이션 프로세스로 전달하는게 트랜스포트가 하는거에요

즉 애플리케이션 프로토콜에서는 메시지 만들어내요 그러고나서 프로세스 투 프로세스 딜리버리를 트랜스포트한테 요청하는거에요

트랜스포트의 목적이 뭐에요? 소스 프로세스 투 데스티네이션 프로세스 딜리버리에요 그쵸

그럼 프로세스 투 프로세스 딜리버리가 있기 위해서는 어때요 먼저 호스트 두 호스트 딜리버리가 이루어져야해요

그래서 이 트랜스포트 계층은 딜리버리를 위해서 호스트 투 호스트 딜리버리를 네트웍 계층한테 요청해요

네트웍 계층에서는 라우팅을 통해서 길찾기에요 그쵸
데스티네이션 호스트가 있고 소스 호스트가 있으면 여기서 길찾기를 하죠 네트웍에서 길찾기를 해서 찾아가고

여기서 여기로 전달해주는게 네트웍 계층이 하는거에요

배달을 하기 위해서 어떻게 해야해요? 홉 바이 홉으로 네트웍 노드를 거쳐가야 해요

한홉 전달하ㄱ ㅣ위해서 누구한테 부탁하냐면 링크 계층한테 부탁해요

네트웍 계층의 목적은 소스 호스트 투 데스티네이션 호스트 딜리버리인데 그러기 위해서는 홉을 건너가야하니까

각 홉을 건너가는 역할을 링크 계층한테 부탁하는거에요

링크 계층은 피지컬 미디엄에다가 비트를 밀어넣어야 하는거에요

그걸 위해서 있는게 피지컬 계층이에요

그 링크 계층은 한홉을 건너가기 위해서 피지컬 계층에다가 데이터를 실어나르는 일을 부탁하게 되어요

종합해보면 인터넷 프로토콜은 몇 계층? 다섯 계층
각 계층은 목적을 가지고 있어요

애플리케이션은 유저 메시지 생성하는 역할을 해
소스에서 데스티네이션으로 배달

프로세스 투 프로세스는 누구한테 부탁? 트랜스포트한테

트랜스포트는 근데 이거 하려면 컴퓨터를 찾아가야돼 호스트 투 호스트 딜리버리는 누구에게? 네트워크 계층에게

네트워크 계층에서는 결국 길을 찾아가기 위해서는 여러 홉을 거쳐야되는데 한홉 거치기 위해서 한홉 거치는 일을 링크 계층에게 부탁

링크 계층은 한홉을 전달하는 일을 목표로하면서 피지컬 미디엄에 비트를 실어야 하는데 그 일을 피지컬 계층에게 부탁

결국 각 계층은 바로 아랫 계층의 서비스를 이용해서 자기 프로토콜 계층의 목표를 달성하는거가 되는거에요

그래서 우리가 이 슬라이드를 통해서 소스에서 데스티네이션까지 메시지가 전달되는 과정을 살펴보겠어요

소스가 여기있고 데스티네이션이 여기 있는데 중간에 라우터 하나와 스위치 하나를 거쳐야해요

소스 호스트와 데스티네이션 호스트에는 어때요? 이 인터넷 프로토콜의 다섯계층이 다 존재해야해요
그런데 라우터에 보면 어디까지밖에 없어요? 네트웍계층까지밖에 없어요

스위치를 보면 링크계층까지밖에 없어요 이유가 뭐냐면 이 애플리케이션 계층의 역할이 뭐에요 네트웍 애플리케이션 프로그램이 만들어내는 데이타를 메시지화 하는거죠
네트웍 애플리케이션이 라우터에서 실행되는 일이 있어요? 없어요 어디서만 실행되어요? 엔드 투 엔드 호스트. 엣지에서 실행되어요
그래서 거기에만 있는거에요

트랜스포트의 역할은 뭐에요? 엔드 투 엔드 프로세스 딜리버리에요 그래서 라우터나 스위치에 들어갈일이 없는거에요 그래서 얘도 엔드 시스템에만 존재해요

네트웍 계층 하는일은? 길찾기에요 길을 찾아서 데스티네이션 호스트까지 가는 일을 해야해요 엔드시스템뿐만 아니라 라우터에도 존재해야해요

다음 홉 어디로 보내야할지 결정해야하므로 ㅇㅇ

스위치라는 장비는 일반적으로 제너럴한 길찾기를 가지고 있지 못해요 왜냐면 네트웍 계층 안가지고 있어요 ㅇㅇ

그래서 이제 보면 소스에서는 애플리케이션 계층에서 메시지를 생성하게 되요
그럼 이거 누구한테 내려보내겠어요? 트랜스포트
애플리케이션이 내려준 메시지에 헤더를 붙여서 세그먼트라는 유닛을 만들게 되요
그러면서 이 트랜스포트는 다시 이 세그먼트를 어디로 내려보낼까요? 네트웍 계층
이 트랜스포트가 내려보낸 메시지(세그먼트)에 네트웍 계층은 또 헤더를 붙이게 되요 네트웍 계층의 헤더 ㅇㅇ
그래서 세그먼트에다가 헤더를 붙여서 데이타그램을 만들게되요 네트웍 계층은 다시 이제 링크 계층으로 보내요
링크 계층으로 내려보내면서 부탁하는 사항이 뭐에요? 다음 홉을 알려주면서 그 다음 홉으로 보내죠
한 홉을 건너갈것을 부탁하는거에요 그러면 얘가 다시 이 데이타그램을 받아서 한홉을 건너가기 위해서 헤더를 붙여요
데이타그램에 링크 계층 헤더를 붙여서 프레임을 만들게 되요
그럼 이제 결국 이걸 피지컬 계층으로 내려보내면 피지컬 계층에서 스위치를 통과하고
그럼 이걸 스위치의 피지컬 계층이 받게되요 여기서 비트를 다 콜렉트해서 얘가 만든 프레임을 그대로 복구해서 라우터로 보내게 되요

링크마다 프레임의 종류가 달라요 그렇기 때문에 요 링크를 통과한 프레임을 받아서 이쪽 링크로 갈 수 있는 프레임을 만들어서 보내요
그럼 이걸 라우터의 피지컬 계층이 받게되요 얘가 프레임을 복구해서 링크 계층으로 올려요 링크 계층은 이 헤더를 보고 한 홉을 제대로 건넜다는걸 확인하고 링크 계층의 헤더를 떼서 올려주게 되요
그럼 (라우터의) 네트웍 계층에서는... 여기 있는 네트웍 계층의 헤더는 누가 만들었을까요? 소스의 네트웍 계층이에요
그래서 다음 홉 어디로 가야겠구나를 이걸 보고 결정한다음 다시 이걸 띠고 자기 헤더를 붙여서 링크로 내려요
링크는 그럼 자기 헤더를 붙여서 프레임 만들어서 피지컬로 내려보내고 피지컬은 데스티네이션으로 보내요
데스티네이션의 피지컬 계층이 받아서 다시 프레임 복구하고 올려보내요
요 링크 계층(데스티네이션의 링크 계층)에서 받은 프레임은 누가 만든 프레임을 받게 된거죠? 그렇죠 라우터
그래서 얘는 어떻게 할까요? 한홉 잘 건너왔네 알면 이걸 띠어요 그리고 올려보낸다는거에요
그러면 이 네트웍 계층에서 받게 되는 이 데이터그램은 누가 만든걸까요? 라우터의 네트웍 계층이에요

그래서 이제 이걸 띠고 내가 데스티네이션이기 때문에 어때요 다음 홉으로 안보내고 위로 올려보내요
얘가 목적지 호스트이므로 네트웍 계층 임무를 완료한거에요 호스트 찾아온거니까 네트웍 계층의 헤더를 띠고 트랜스포트로 올려보내요

소스에서 만들었던 세그먼트를 이제 트랜스포트가 보게되죠 이걸 띠고 애플리케이션으로 올려주면
소스에서 만든 데이터를 애플리케이션 계층에서 보게 되는거에요

슬라이드 내용 정리!
일단 첫번째 사항은 엔드 시스템만이 프로토콜 풀 스택을 가지고 있다는거에요
그리고 각 프로토콜 계층마다 뭘 붙여요? 자기 임무를 수행하기 위해서 헤더를 붙여요
그 헤더는 누가 읽는게 목적이죠? 나의 피어가 읽는게 목적이에요
그래서 이 경우 소스의 피어가 어디에 존재해요?
트랜스포트랑 애플리케이션은 데스티네이션에만 존재, 네트웍의 피어는? 다음홉(라우터)에 존재해요
소스 링크 계층의 피어는 스위치, 스위치 링크 계층의 피어는 라우터
이 피어들끼리 협력을 잘해서 소스에서 데스티네이션까지 배달!
트랜스포트끼리는? 우리가 데이타를 잘 주고 받았다는걸 확인
각 프로토콜 계층에서 만들어내는 데이타 유닛은? 프로토콜 데이타 유닛(PDU)

* application : message
* transport : segment
* network : datagram
* link : frame

자 그래서 이게 전체적인 개념이에요

사실 이 프로토콜의 각 계층에 보안 매커니즘이 추가되어야해요

인터넷이 처음 만들어질 당시에는 서로를 이미 잘 아는 몇몇 과학자들간에 데이타를 주고받기 위한 네트웍이었어요

그래서 이 네트웍의 유저는 굉장히 세이프한 사람들이에요 하지만 90년대 이후에 상용화되면서 사람이 늘어나고
시큐리티가 중요하게 된거죠

오리지날 프로토콜 자체에는 시큐리티 매커니즘이 없었어요 그렇지만 필요하게 된거죠 첨가할 수 있어야되게

시큐리티 영역에는 우선 컴퓨터 네트웍에 대한 공격의 종류가 어떤게 있냐 아이덴티파이하는게 첫번째 에어리어에요
그러한 공격에 대해서 어떻게 디펜스를 해야될건가 두번째 에어리어
마지막으로 원천적으로 어떤 공격에 이면한 네트웍 시스템을 빌드하는것이 세번째 에어리어

그래서 우리가 네트웍 시큐리티에 대해 책 뒤에 나오지만 여기서는 일단 간단하게만 설명 ㅇㅇ

보통 악성코드를 총칭해서 멀웨어라고 해요
멀웨어는 virus랑 worm 둘의 차이가 뭐냐면 액티브되는 방법이 달라요
virus : self-replicating infection by receiving / executing object
worm : self-replicating infection by passively receiving object

바이러스는 받고 & 실행해야
웜은 받기만 하면 저절로 구동이 되서 실행하고 전파되고

흔히 컴퓨터에 있는 멀웨어중에 스파이웨어라는게 있는데 얘는 뭘하느냐
여러분의 키스트록이나 어떤 웹사이트를 비짓한다던지 뭘 업로드 했다던지 콜렉션 사이트에 리포팅하는게 스파이웨어라고 해요

봇넷이라는건 뭘 의미하냐면 스팸이나 디도스 어택을 위해서 활용되는 오염된 컴퓨터의 집합

공격의 종류들 유형을 살펴보면 디나이얼 오브 서비스
여기서 쓸모없는 가비지 트래픽을 계속 보내서 실제 사용자에게 응답하지못하게 어택하는게 도스 어택

이 도스 어택이 진행되기 위해서는 타겟이 필요하고
타겟 주변의 컴퓨터에게 멀웨어를 보내서 봇넷을 만들어요
봇넷에 속한 컴퓨터의 역할이 뭐냐면 스팸이나 쓸데없는 트래픽을 타겟으로 보내는 역할을 하는거에요
이 서버는 이제 바빠져서 어때요 실질적인 사용자에게 응대를 할 수 없게 되는거죠

그다음에 스니핑이라는것 스니핑이 발생할 수 있는것은 와이파이 혹은 쉐어드 인터넷 이런데서 발생할 수 있어요

이런 미디어들이 브로드캐스트 미디어이기 때문에 그래요 이게 모냐면
미디엄에 여러 호스트들이 어태치되어있고 걔네들이 어때요 이 미디어를 쉐어링하는거에요
가령 여러분이 와이파이같은 경우에는 여러분의 와이파이를 공유하는 액세스 포인트를 공유하는 여러 호스트들이 다 그 와이파이 미디어를 공유를 하게 되는거에요
그러면 이런 브로드캐스팅 미디어 같은 경우는 실제로 그 브로드캐스팅 미디어에 어태치 되어있는 모든 호스트들이 사실 마음만 먹으면 지나가는 모든 트래픽을 다 볼 수 있어요
하지만 어떻게 하냐면 네트워크에 연결하기 위해서는 NIC가 네트웍 인터페이스카드가 엔드 시스템이 다 꽂히게 되요
여기에는 물리적으로 고유한 이 어드레스가 있어요 NIC마다 할당되는
그럼 이제 NIC에서 하는 일 피지컬에서 하는일은 뭐냐면 링크계층에서 프레임을 받으면 이 프레임에 적힌 주소를 보고 그게 내 NIC 주소와 일치하면?
프레임을 받아들여서 윗 계층으로 올려보내고 일치하지 않으면 프레임을 드랍시켜버려요
그래서 윗계층으로 올라가지 않게 ㅇㅇ

그리고 나의 NIC의 물리적인 주소가 아니라 할지라도 브로드캐스트 어드레스가 또 있을 수 있어요 이건 어때요 미디엄에 연결된 모든 호스트는 다 받아보는 그런 프레임이죠

그런 경우에 이 두가지 경우에 나에게 온 경우나 브로드캐스트가 온 경우에 올려보내게 되어있는데 간혹가다가 이 NIC를 갖다가 promiscuous 모드로 세팅할 수 있어요
이 모드를 허요ㅠㅇ하는 이유는 관리차원에서 ㅇㅇ 관리자가 이 네트웍에 지나가는 모든 프레임을 조사할 의무가 있다거나 하면 저 모드로 NIC 세팅할 수 있어요
그렇게 되면 나를 데스티네이션으로 하는 프레임이 아니더라도 위로 올려보내게 되는거에요
근데 윗 계층에 멀웨어가 있으면 걔가 다 받아보는거에요 다 감시하는거죠

가령 뱅크 업무하면서 패스워드같은거 실어보내는걸 다 볼수도 있다는거죠 그걸 패킷 스니핑이라는거에요

IP 스푸핑이라는게 있는데 네트웍에 매달린 어떤 호스트가 자기가 딴애인척 하는거에요
그래서 마치 자기가 B인척 하고(C가) 다른 애의 소스 어드레스인척하고 보내는거에요

(이후 인터넷의 역사 설명)


```