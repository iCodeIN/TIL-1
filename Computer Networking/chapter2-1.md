```

1장에서 인터넷의 구조와 요소들 살펴봤고 프로토콜이 무엇인가 네트워크 퍼포먼스를 어떤 메트릭으로 우리가 얘기를 하냐 그리고 시큐리티 인터넷 히스토리
여러가지 주제 얘기했어요

2장에서는 본격적으로 각 프로토콜 계층을 살펴볼건데요
제일 먼저 살펴보게 될 것이 어플리케이션 계층이 되겠어요

지난시간에 얘기한대로 우리가 앞으로 공부할 챕터들에서 많이 사용할 용어들과 기본적인 개념은 1장에서 소개했기 때문에 1장을 다 알고 들어가는 것이 강의 진행하는데 매우 도움이 됩니다

애플리케이션 계층을 얘기할때 우리가 세가지 주제를 나눠서 얘기할거에요
먼저 애플리케이션의 구조와 개념에 대해서 제너럴한 소개를 하고, 그다음에는 실제로 인터넷에서 보편적으로 사용되고 있는 이러한 프로토콜들을 직접 살펴볼거에요

그리고 마지막으로 여러분 스스로가 네트웍 애플리케이션 프로그램을 작성할 수 있는 인터페이스를 한번 공부를 해보도록 하겠어요
소켓 API라는건데 그걸 공부해볼거에요

먼저 개념과 구조, 그리고 실 예제, 그리고 소켓 API 세가지 주제를 공부하게 될거에요

여기에 매우 보편적인 네트워크 애플리케이션의 리스트가 있어요 이중에 대다수를 매우 빈번하게 사용하고 있을거에요

* Some network apps (Application Layer 슬라이드 2-3)
- e-mail, web, text messaging remote login, p2p 등...

(예시로 나온 애플리케이션에 대해 가볍게 얘기)

자 이렇게 다양한 애플리케이션들이 있는데 이들 애플리케이션은 두가지 구조중 하나를 가져요

* Application architectures
possible structure of applications : client-server, peer-to-peer (P2P)

클라이언트 서버 아키텍쳐, 피어투피어 아키텍쳐중 하나를 취하게 되요
네트웍 애플리케이션 프로그램이 이 두가지 구조중 하나를 취할뿐 아니라, 그 프로그램을 지원하는 프로토콜도 두 구조중 하나를 취하게 되어요

* Client-server architecture
- server
    - always-on host
    - permanent IP address
    - data centers for scaling

- clients
    - communicate with server
    - do not communicate directly with each other
    - may be intermittently connected
    - may have dynamic IP addresses

(클라이언트-서버 아키텍쳐에서) 커뮤니케이션을 하는 실질적인 주체는 누구에요? 호스트에요? 프로그램이에요?
컴퓨터가 커뮤니케이션을 해요? 아니에요 실제로 실행되고 있는 프로그램이 커뮤니케이션을 하는거에요

그 프로그램이 시딩하고 있는 호스트가 클라이언트-서버 아키텍쳐인 경우에는 한종류는 서버고 한종류는 클라이언트에요
그래서 서버 호스트는 어떤 호스트냐면 언제나 ON되어있는 호스트에요 물론 시스템이 일시적으로 셧다운일때도 있지만 컨셉츄얼리 서버는 항상 ON인 호스트여야해요
그리고 영구적으로 할당된 아이피 주소를 가지고 있는 호스트에요. 그리고, 클라이언트가 많을때는 그 많은 클라이언트를 응대하기 위해서 데이타 센터 형식으로 여러 동일한 기능을 하는 서버가 군집되어있는
그런 형태로 존재하기도 해요

그리고 클라이언트 호스트는, 자기들끼리 절대로 통신하는 일이 없어요 항상 서버랑 통신을 해요
서버랑 대조적으로 클라이언트 호스트들은, intermittently하게 커넥트 되어요 커넥트 됐다가 안됐다가 하고
아이피 주소도 다이나믹 IP주소 할당받는 경우가 많아요
다이나믹 IP주소는 인터넷에 연결될때마다 변경 가능한 주소에요

그래서 클라이언트 서버 아키텍쳐에서는 서버 호스트에서 실행되고 있는 프로세스와 클라이언트 호스트에서 실행되고 있는 프로세스가 서로 통신을 하게 되는거에요

* P2P architecture
- no always-on server
- arbitrary end systems directly communicate
- peers request service from other peers, provide service in return to other peers
    - self scalability - new peers bring new service capacity, as well as new service demands
- peers are intermittently connected and change IP addresses
    - complex management

반면에, 피어 투 피어 아키텍쳐에 대해서는 커뮤니케이트 하는 두 프로세스가 모두 유저 호스트에 시딩하고 있어요 그래서 이 P2P 아키텍쳐에서는
always 서버가 존재하지 않아요 그래서 그냥 서로 커뮤니케이션 하는거에요

커뮤니케이트 하는 유저 호스트를 피어라고 불러요
피어는 다른 피어로부터 서비스를 리퀘스트 하기도 하고 반대로 다른 피어에게 자기가 서비스를 제공해주기도 해요

이 피어 투 피어 아키텍쳐의 대표적인 장점이 뭐냐면 self scalability에요
클라이언트 아키텍쳐에서는 서버 호스트에게로 어때요 서버 호스트와 모든 클라이언트들이 통신을 하는거에요 클라이언트수가 많아지면 어때요 서버를 증가시켜야하죠
그런데 이 피어투피어에서는 별도로 서버가 없고 피어들끼리 서비스를 제공하기도 하고 상대로부터 서비스 받기도 하고
그렇기 때문에 어떤 피어가 시스템을 조인하면 그 피어는 리퀘스트만 갖고 들어오는게 아니라 서비스 캐퍼빌러티?까지도 가지고 들어오기 때문에 시스템의 규모가 커지더라도 서브스케일? 할 수 있는 경향이 있어요 (여기 잘 안들린다..)

하지만, 이 피어투피어 구조에서의 피어들은 일반 유저 호스트에요 그쵸? 그렇기 때문에 인터넷에 intermittently하게 커넥트되고, 다이내믹 IP를 받는다던가 하는 이유로 관리가 복잡하다는 단점을 가지고 있어요
그래서 우리가 이제 두가지 구조에서 보면, 호스트를 우리가 구분을 했어요
커뮤니케이션을 하는 주체가 누구에요? 호스트가 아니라 그 안에서 실행되는 네트웍 애플리케이션(프로그램)이에요 실행중인 프로그램을 프로세스라고 하죠
여러분이 운영체제에서 프로세스간 통신하는걸 아마 배웠을거에요

근데, 이 네트웍에서는 뭘 배우냐면 서로 다른 호스트에 시딩하고 있는 프로세스들 간에 메시지를 교환함으로서 통신하는 것을 얘기할거에요
자 그래서, 이 통신하는 프로세스는 두 종류로 나뉘어요. 그러니까 네트웍 애플리케이션 프로그램은 어때요?
서로 커뮤니케이션을 함으로서 어떤 작업을 달성하는.. 커뮤니케이션하고 있는 프로세스들로 이 네트웍 애플리케이션 프로그램들이 구성되는거에요

이 프로세스는 두 종류로 나뉜다는거에요 서버 프로세스 클라이언트 프로세스 ㅇㅇ

클라이언트 프로세스는 커뮤니케이션을 이니시에이트 하고 있는거
서버 프로세스는 클라이언트 프로세스의 컨택트를 받아서 대기하고 있다가 컨택트를 받으면 응대하는것이 서버 프로세스ㅇㅇ

클라이언트 서버 아키텍쳐 같은 경우는 클라이언트 프로세스가 어느 호스트에서 실행되고 있을가요? 

클라이언트 호스트에서 실행이 되고있죠
서버 프로세스는 서버 호스트에서 실행되고 ㅇㅇ

그렇다면 피어투피어의 경우에는 어떻게 될까요? 이 피어안에 클라이언트도 실행되고 있고 서버도 동시에 실행되고 있을수가 있어요

피어 호스트 안에는 클라이언트 프로세스와 서버 프로세스가 동시에 실행되고 있을수도 있고 둘중 하나만 실행되고 있을수도 있고 그래요

근데 우리가 지난시간에, 프로토콜 레이어링을 공부하면서 애플리케이션 계층에서는 메시지를 만들어서 그쵸?
교환할 메시지를 만들어서 그걸 누구에게 딜리버리 부탁한다고 그랬어요? 트랜스포트한테 부탁한다 그랬죠
이 애플리케이션 프로세스는 디벨로퍼가 컨트롤 하는 영역이고, 트랜스포트 계층 이하는 운영체제에 의해서 컨트롤되는 파트에요

여러분 작성하는 프로그램이, 유저 영역의 프로세스로 실행되는거구요
운영체제가 실행하는 프로세스들이 있어요, 트랜스포트 계층 이하는 운영체제가 컨트롤하는 프로세스들이 되겠어요

애플리케이션 계층에서 만들어낸 메시지는, 트랜스포트 계층으로 딜리버리를 부탁을 하게 되고
또 네트웍을 통해서 배달된 메시지는 어때요? 역시 트랜스포트 계층을 거쳐서 애플리케이션으로 배송이 이루어지게 되어요

그래서 이 계층간에는 도어같은게 필요한데 이걸 소켓이라고 해요
내보낼때도 소켓 통해서 내보내고 받아오는 메시지도 소켓 통해서 읽어오는게 되겠어요

자 그래서, 커뮤니케이션은 결국 두 호스트간에 이루어지는게 아니라 두개의 호스트에 시딩하고 있는 프로세스간에 이루어지는거에요

이 커뮤니케이션 하는.. 메시지가 딜리버리 되어야하는 목적지는 호스트에요 프로세스에요? 프로세스에요! 그쵸

그러면 과연 목적지를 어떻게 식별을 할거냐?에요

여러분 우리가 우편물같은 경우는 최종 목적지가 집이에요, 아니면 그 집에 있는 특정 인물이에요? 특정 인물이죠

그럼 봉투에 받는 사람 수신인이 어떻게 식별이 되어요? 주소 그리고 사람의 이름

그래서 호스트 아이피 주소만 가지고는 궁극적인 목적지인 메시지가 딜리버리되어야할 애플리케이션 프로세스는 식별할 수 없어요

이 호스트를 식별하는 32비트 아이피 주소와 더불어, 포트 번호라는 것을 사용해요 이 포트 번호는 호스트 안에서 실행되고 있는 어떤 프로세스를 갖다가 아이덴티파이 해주는 번호가 되겠어요

한 호스트 안에 프로세스 하나만 실행되고 있을까요? 여러 프로세스 실행디ㅗ고 있겠죠
그래서 이 포트 번호를 가지고 배달할 프로세스를 식별하게 되는거에요
그런데, http같은거는 이거는 웹 애플리케이션을 위한 프로토콜이에요 http서버의 포트번호는 언제나 80으로 고정이 되어있어요
어떤 웹서버이건간에 http서버 프로세스의 포트 번호는 얼마라구요? 80을 사용해요
이게 왜그러냐면 메일 서버의 경우에는 메일 서버 프로세스는 포트 번호 25를 사용해요 
이런걸 well-known port라고 불러요
매우 보편적으로 사용되는 서버 프로세스의 경우는 고정된 포트 번호로 사용을 해요
왜냐면 서버 프로세스들은 여러 클라이언트들이 컨택을 해요 그럼 컨택할때 어때요?
파이널 데스티네이션의 포트 번호 명시해야되는데 그걸 다 알고 있게 하기 위해서에요
어느 클라이언트 프로세스나 내가 이 http서버 프로세스에게 뭔가 리퀘스트 해야한다 하면 ㅇㅇ
그 서버의 아이피 주소는 다 달라지겠지만, 포트 번호는 항상 이걸로 고정이 되는거에요

그래서 ip주소는 이렇게 생겼죠 (128.119.245.12)
실제 ip주소는 32비트에요
이 숫자를 세자리 숫자가 8비트 2진수에 해당하는 숫자에요
맥시멈은 255가 되겠죠
그래서 32비트를 쫙 0과 1의 시퀀스로 나열하면 사람이 보기 힘들기 때문에 이런 노테이션을 사용하는거에요 8비트씩 짤라서.

그래서 호스트는 아이피 주소로 식별을 하고, 포트번호로 그 호스트내에서 프로세스를 식별하게 되는거에요

자 그래서 이제 어플리케이션에서는 데이타 딜리버리를 트랜스포트 계층에 부탁하게 되는데, 그럼 과연 어떤 트랜스포트 서비스를 원할까? 를 우리가 한번 생각해보도록 하겠어요

어떤 애플리케이션에 대해서는 data integrity가 중요해요
예를 들어.. 파일 트랜스퍼나 웹 트랜젝션 같은 경우 ㅇㅇ




```