```

1장에서 인터넷의 구조와 요소들 살펴봤고 프로토콜이 무엇인가 네트워크 퍼포먼스를 어떤 메트릭으로 우리가 얘기를 하냐 그리고 시큐리티 인터넷 히스토리
여러가지 주제 얘기했어요

2장에서는 본격적으로 각 프로토콜 계층을 살펴볼건데요
제일 먼저 살펴보게 될 것이 어플리케이션 계층이 되겠어요

지난시간에 얘기한대로 우리가 앞으로 공부할 챕터들에서 많이 사용할 용어들과 기본적인 개념은 1장에서 소개했기 때문에 1장을 다 알고 들어가는 것이 강의 진행하는데 매우 도움이 됩니다

애플리케이션 계층을 얘기할때 우리가 세가지 주제를 나눠서 얘기할거에요
먼저 애플리케이션의 구조와 개념에 대해서 제너럴한 소개를 하고, 그다음에는 실제로 인터넷에서 보편적으로 사용되고 있는 이러한 프로토콜들을 직접 살펴볼거에요

그리고 마지막으로 여러분 스스로가 네트웍 애플리케이션 프로그램을 작성할 수 있는 인터페이스를 한번 공부를 해보도록 하겠어요
소켓 API라는건데 그걸 공부해볼거에요

먼저 개념과 구조, 그리고 실 예제, 그리고 소켓 API 세가지 주제를 공부하게 될거에요

여기에 매우 보편적인 네트워크 애플리케이션의 리스트가 있어요 이중에 대다수를 매우 빈번하게 사용하고 있을거에요

* Some network apps (Application Layer 슬라이드 2-3)
- e-mail, web, text messaging remote login, p2p 등...

(예시로 나온 애플리케이션에 대해 가볍게 얘기)

자 이렇게 다양한 애플리케이션들이 있는데 이들 애플리케이션은 두가지 구조중 하나를 가져요

* Application architectures
possible structure of applications : client-server, peer-to-peer (P2P)

클라이언트 서버 아키텍쳐, 피어투피어 아키텍쳐중 하나를 취하게 되요
네트웍 애플리케이션 프로그램이 이 두가지 구조중 하나를 취할뿐 아니라, 그 프로그램을 지원하는 프로토콜도 두 구조중 하나를 취하게 되어요

* Client-server architecture
- server
    - always-on host
    - permanent IP address
    - data centers for scaling

- clients
    - communicate with server
    - do not communicate directly with each other
    - may be intermittently connected
    - may have dynamic IP addresses

(클라이언트-서버 아키텍쳐에서) 커뮤니케이션을 하는 실질적인 주체는 누구에요? 호스트에요? 프로그램이에요?
컴퓨터가 커뮤니케이션을 해요? 아니에요 실제로 실행되고 있는 프로그램이 커뮤니케이션을 하는거에요

그 프로그램이 시딩하고 있는 호스트가 클라이언트-서버 아키텍쳐인 경우에는 한종류는 서버고 한종류는 클라이언트에요
그래서 서버 호스트는 어떤 호스트냐면 언제나 ON되어있는 호스트에요 물론 시스템이 일시적으로 셧다운일때도 있지만 컨셉츄얼리 서버는 항상 ON인 호스트여야해요
그리고 영구적으로 할당된 아이피 주소를 가지고 있는 호스트에요. 그리고, 클라이언트가 많을때는 그 많은 클라이언트를 응대하기 위해서 데이타 센터 형식으로 여러 동일한 기능을 하는 서버가 군집되어있는
그런 형태로 존재하기도 해요

그리고 클라이언트 호스트는, 자기들끼리 절대로 통신하는 일이 없어요 항상 서버랑 통신을 해요
서버랑 대조적으로 클라이언트 호스트들은, intermittently하게 커넥트 되어요 커넥트 됐다가 안됐다가 하고
아이피 주소도 다이나믹 IP주소 할당받는 경우가 많아요
다이나믹 IP주소는 인터넷에 연결될때마다 변경 가능한 주소에요

그래서 클라이언트 서버 아키텍쳐에서는 서버 호스트에서 실행되고 있는 프로세스와 클라이언트 호스트에서 실행되고 있는 프로세스가 서로 통신을 하게 되는거에요

* P2P architecture
- no always-on server
- arbitrary end systems directly communicate
- peers request service from other peers, provide service in return to other peers
    - self scalability - new peers bring new service capacity, as well as new service demands
- peers are intermittently connected and change IP addresses
    - complex management

반면에, 피어 투 피어 아키텍쳐에 대해서느 ㄴ커뮤니케이트 하는 두 프로세스가 모두 유저 호스트에 시딩하고 있어요 그래서 이 P2P 아키텍쳐에서는
always 서버가 존재하지 않아요 그래서 그냥 서로 커뮤니케이션 하는거에요

커뮤니케이트 하는 유저 호스트를 피어라고 불러요
피어는 다른 피어로부터 서비스를 리퀘스트 하기도 하고 반대로 다른 피어에게 자기가 서비스를 제공해주기도 해요

이 피어 투 피어 아키텍쳐의 대표적인 장점이 뭐냐면 self scalability에요
클라이언트 아키텍쳐에서는 서버 호스트에게로 어때요 서버 호스트와 모든 클라이언트들이 통신을 하는거에요 클라이언트수가 많아지면 어때요 서버를 증가시켜야하죠
그런데 이 피어투피어에서는 별도로 서버가 없고 피어들끼리 서비스를 제공하기도 하고 상대로부터 서비스 받기도 하고
그렇기 때문에 어떤 피어가 시스템을 조인하면 그 피어는 리퀘스트만 갖고 들어오는게 아니라 서비스 캐퍼빌러티?까지도 가지고 들어오기 때문에 시스템의 규모가 커지더라도 서브스케일? 할 수 있는 경향이 있어요 (여기 잘 안들린다..)

```